<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Ghost's Blog]]></title><description><![CDATA[Toward human-like A.I.]]></description><link>https://bosoek.github.io</link><generator>GatsbyJS</generator><lastBuildDate>Thu, 08 Dec 2022 06:22:11 GMT</lastBuildDate><item><title><![CDATA[Flutter 쓸 거 같은 패키지들]]></title><description><![CDATA[Flutter 쓸 거 같은 패키지들 Flutter는 비교적 타 프레임워크에 비해(rn…]]></description><link>https://bosoek.github.io/flutter_packages/</link><guid isPermaLink="false">https://bosoek.github.io/flutter_packages/</guid><pubDate>Tue, 06 Dec 2022 10:00:00 GMT</pubDate><content:encoded>&lt;hr&gt;
&lt;h1&gt;Flutter 쓸 거 같은 패키지들&lt;/h1&gt;
&lt;p&gt;Flutter는 비교적 타 프레임워크에 비해(rn 등..) 많이 어리고 관련 패키지가 적은 편이다. 하지만 이제는 몇년 전에 비해 패키지 수도 많고 재밌는 패키지도 몇게 보여서 나중에 내가 개발시에 쓸 것 같은 패키지들, 사용 자주하는 패키지들을 기록해둔다.&lt;/p&gt;
&lt;h4&gt;1. flutter_svg&lt;/h4&gt;
&lt;p&gt;flutter에서 svg 이미지를 사용할 수 있는 패키지이다.&lt;/p&gt;
&lt;p&gt;좋아요 수나 인기도가 굉장히 높고 개발시에 디자인을 적용하게 되는 경우에는 거의 필수적으로 사용하게 될 패키지라고 생각된다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://pub.dev/packages/flutter_svg&quot;&gt;pub.dev에서 보기&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;import code : &lt;code class=&quot;language-text&quot;&gt;import &apos;package:flutter_svg/flutter_svg.dart&apos;;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;2. cached_network_image&lt;/h4&gt;
&lt;p&gt;인터넷 이미지를 url을 통해 가져와 쓸 경우 다운로드 비용 절감을 위해 캐시로 관리해야 한다. 이를 위한 패키지이다.&lt;/p&gt;
&lt;p&gt;좋아요, 인기 모두 높고 이 패키지 역시 개발시에 반드시 사용하게 되는 패키지라고 생각한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://pub.dev/packages/cached_network_image&quot;&gt;pub.dev에서 보기&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;import code : &lt;code class=&quot;language-text&quot;&gt;import &apos;package:cached_network_image/cached_network_image.dart&apos;;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;3. easy_pip &amp;#x26; flutter_android_pip&lt;/h4&gt;
&lt;p&gt;PIP(Picture-in-picture) 기능 구현시에 사용하는 패키지들이다. 참고로 PIP는 아래처럼 앱 위에 보여지는 기능들이다.&lt;/p&gt;
&lt;img src=&quot;https://i.ytimg.com/vi/AlTbJHLcpQ4/maxresdefault.jpg&quot; width=&quot;500&quot;&gt;
&lt;p&gt;내부 페이지 위에서 구현시 easy_pip, 외부 앱 위에서 구현시 flutter_android_pip를 사용한다.&lt;/p&gt;
&lt;p&gt;음악이나 영상 데이터 이용시에는 필수적일 것 같다. 아직까지는 사용해 본 경험이 없지만 앞으로 개발하면서 사용하게 될 듯 싶다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://pub.dev/packages/easy_pip&quot;&gt;easy_pip pub.dev에서 보기&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;easy_pip import code : &lt;code class=&quot;language-text&quot;&gt;import &apos;package:easy_pip/easy_pip.dart&apos;;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://pub.dev/packages/flutter_android_pip&quot;&gt;flutter_android_pip pub.dev에서 보기&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;easy_pip import code : &lt;code class=&quot;language-text&quot;&gt;import &apos;package:flutter_android_pip/flutter_android_pip.dart&apos;;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;4. flutter_local_notifications&lt;/h4&gt;
&lt;p&gt;flutter에서 로컬 push notification을 보낼 때 사용하는 패키지이다. 굳이 파베상으로 전부 처리 가능한 push notification을 로컬 패키지로 만든 이유는…&lt;/p&gt;
&lt;img src=&quot;https://user-images.githubusercontent.com/68007145/205898193-931e2154-efa1-42ea-b7f1-f96b728dc8e8.jpg&quot; width=&quot;400&quot;&gt;
&lt;p&gt;이런식으로 여러 notification 효과를 낼 수 있기 때문이다. 위 방식 외에도 정말 시간 설정, 묶음 효과 등등 별의별 방식으로 사용 가능하기에 서비스를 운영하는 과정에서 필요한 패키지일 것 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://pub.dev/packages/flutter_local_notifications&quot;&gt;pub.dev에서 보기&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;easy_pip import code : &lt;code class=&quot;language-text&quot;&gt;import &apos;package:flutter_local_notifications/flutter_local_notifications.dart&apos;;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;5. shared_preferences&lt;/h4&gt;
&lt;p&gt;flutter에서 디바이스 DB를 사용할 수 있게 해주는 패키지이다. sqflite보다 사용하기 간단하고 쉽다는 장점이 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://pub.dev/packages/shared_preferences&quot;&gt;pub.dev에서 보기&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;easy_pip import code : &lt;code class=&quot;language-text&quot;&gt;import &apos;package:shared_preferences/shared_preferences.dart&apos;;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;6. modal_bottom_sheet&lt;/h4&gt;
&lt;p&gt;아래와 같은 바텀 시트를 사용할 수 있게 해주는 패키지이다. 바텀 시트의 경우 앱에서 굉장히 다양하게 사용되기 때문에 알아두면 좋다고 생각한다.&lt;/p&gt;
&lt;img src=&quot;https://github.com/jamesblasco/modal_bottom_sheet/blob/screenshots/modal_inside_modal.gif?raw=true&quot; width=&quot;300&quot;&gt;
&lt;p&gt;참고로 modal_bottom_sheet의 경우 border radius 설정이 힘든데 이럴 때는 flutter 기본으로 제공하는 showBottomSheet를 사용하면 편하다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://pub.dev/packages/modal_bottom_sheet&quot;&gt;pub.dev에서 보기&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;easy_pip import code : &lt;code class=&quot;language-text&quot;&gt;import &apos;package:modal_bottom_sheet/modal_bottom_sheet.dart&apos;;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;h3&gt;1퍼센트의 가능성, 그것이 나의 길이다. -나폴레옹(Napoléon)&lt;/h3&gt;
&lt;p&gt;The possibility of 1 percent, that’s my way.&lt;/p&gt;
&lt;/blockquote&gt;</content:encoded></item><item><title><![CDATA[Git commit 규칙 설정]]></title><description><![CDATA[Git commit…]]></description><link>https://bosoek.github.io/gitmessage_setting/</link><guid isPermaLink="false">https://bosoek.github.io/gitmessage_setting/</guid><pubDate>Sun, 20 Nov 2022 10:00:00 GMT</pubDate><content:encoded>&lt;hr&gt;
&lt;h1&gt;Git commit 규칙 설정&lt;/h1&gt;
&lt;p&gt;협업시에 깃을 사용하여 버전 관리 및 커밋을 남겼는데 최근 인턴으로 일하며 커밋 메시지의 중요성에 대해 생각하게 되었다. 기존에는 너무 난잡하게 작성하는 경우가 많았고 또 회사에서 사용하지 않는 태그도 있다는걸 알게되었다.(이태까지 ADD를 회사에서도 사용하는 줄 알았다)&lt;/p&gt;
&lt;p&gt;협업으로 깃을 사용한다면 커밋 메시지의 일관성은 매우 중요하고, 다른 사람들이 내 코드를 읽을 때와, 커밋 메시지로 업무 내용을 파악하기도 하기에 Git commit 규칙을 설정하여 커밋 일관성을 지켜볼려고 한다.&lt;/p&gt;
&lt;h3&gt;1. .gitmessage.txt 생성&lt;/h3&gt;
&lt;p&gt;위치는 어디든 크게 상관은 없지만 편하게 파악하기 위해 루트나 .gitignore와 같은 위치를 추천한다.&lt;/p&gt;
&lt;h3&gt;2. 커밋 규칙 작성&lt;/h3&gt;
&lt;p&gt;.gitmessage.txt 파일에 커밋 메시지 규칙을 작성한다.&lt;/p&gt;
&lt;p&gt;회사나 팀에서 회의 후 결정된 사항들을 적는다&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;아래는 예시 파일&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;# &amp;lt;타입&gt; : &amp;lt;제목&gt; 형식으로 작성하며 제목은 최대 50글자 정도로만 입력
# 제목을 아랫줄에 작성, 제목 끝에 마침표 금지, 무엇을 했는지 명확하게 작성

################
# 본문(추가 설명)을 아랫줄에 작성

################
# 꼬릿말(footer)을 아랫줄에 작성 (관련된 이슈 번호 등 추가)

################
# FEAT : 새로운 기능
# FIX : bug fix
# REFACTOR : 리팩토링
# TEST : 테스트용
# CHORE : 빌드 및 패키징 관련
################&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3. git config 설정&lt;/h3&gt;
&lt;p&gt;git commit시에 .gitmessage.txt 파일을 참조할 수 있도록 설정해야 한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;git config --global commit.template [.gitmessage.txt 파일 경로]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이러면 commit 규칙 설정은 끝이다. 이후부터 commit 시에 &lt;code class=&quot;language-text&quot;&gt;git commit -m &quot;&quot;&lt;/code&gt; 이 아니라 &lt;code class=&quot;language-text&quot;&gt;git commit&lt;/code&gt;만 작성하면 위에 작성한 템플릿이 뜬다&lt;/p&gt;
&lt;img src=&quot;https://s3.us-west-2.amazonaws.com/secure.notion-static.com/80feee19-9476-40a3-a325-e83a62924d69/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;amp;X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&amp;amp;X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20221206%2Fus-west-2%2Fs3%2Faws4_request&amp;amp;X-Amz-Date=20221206T023816Z&amp;amp;X-Amz-Expires=86400&amp;amp;X-Amz-Signature=117526759e35e2b59f4740171eb13bdba16572d44fd6cc99f8eb1e6cb4733e44&amp;amp;X-Amz-SignedHeaders=host&amp;amp;response-content-disposition=filename%3D%22Untitled.png%22&amp;amp;x-id=GetObject&quot; width=&quot;500&quot;&gt;
&lt;p&gt;i 또는 a를 입력하여 커밋 메시지 작성 후 esc + &lt;code class=&quot;language-text&quot;&gt;:wq&lt;/code&gt;를 작성하면 된다.&lt;/p&gt;
&lt;p&gt;따로 노션등에 커밋 규칙을 작성하는 방법보다 커밋 시에 바로 바로 보면서 작성이 가능하기에 훨씬 더 효과적인 방법인 것 같다.&lt;/p&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;h3&gt;고객을 ‘유저’라고 부르는 산업은 딱 두 개가 있다. 마약과 IT -에드워드 터프테&lt;/h3&gt;
&lt;p&gt;There are only two industries that call customers ‘users’. Drugs and IT&lt;/p&gt;
&lt;/blockquote&gt;</content:encoded></item><item><title><![CDATA[개발 방법론 개념 정리(tdd, ddd)]]></title><description><![CDATA[개발 방법론 개념 정리(tdd, ddd) 최근에 인턴직을 하며 회사 코드도 뜯어보고 사수 분과 개발에 대해 이야기 하다가 DDD…]]></description><link>https://bosoek.github.io/development_methodology/</link><guid isPermaLink="false">https://bosoek.github.io/development_methodology/</guid><pubDate>Thu, 17 Nov 2022 10:00:00 GMT</pubDate><content:encoded>&lt;hr&gt;
&lt;h1&gt;개발 방법론 개념 정리(tdd, ddd)&lt;/h1&gt;
&lt;p&gt;최근에 인턴직을 하며 회사 코드도 뜯어보고 사수 분과 개발에 대해 이야기 하다가 DDD관련 개발 방법론을 주제로 이야기 하게 되었다.&lt;/p&gt;
&lt;p&gt;개인적으로는 아키텍처나 클린코드는 평소에 공부를 했었는데 개발 방법론은 교과서에서 잠깐만 보고 직접 공부해보지 않은 것 같아 간단히 정리하려고 한다.&lt;/p&gt;
&lt;h3&gt;1. 개발 방법론이란?&lt;/h3&gt;
&lt;p&gt;개발 방법론은 소프트웨어를 생산시에 필요한 프로그래밍 개발 과정들을 정리하고 표준화하여 프로그래머들이 개발과정에서 일관성을 유지하고 효과적인 협업이 이루어질수 있도록 돕기 위한 방법론이다.&lt;/p&gt;
&lt;p&gt;즉, 방법론은 &lt;strong&gt;무엇을, 어떻게 해야 하는지 가이드를 제시&lt;/strong&gt; 하기 위한 메뉴얼이다.&lt;/p&gt;
&lt;p&gt;가장 대중적인 방법론을 소개하자면 폭포수 방법론과 애자일 방법론이 있다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;폭포수 방법론&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;개발 설계 → 구현 → 테스트 → 유지보수&lt;/p&gt;
&lt;p&gt;위의 과정을 순차적으로 진행하고 이전 단계로 돌아가지 않는 것이 특징이다.&lt;/p&gt;
&lt;p&gt;각 과정 진행 이해는 용이하지만 수정사항 발생시에 리소스가 많이 들어간다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;애자일 방법론&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;기능을 작게 나눠 구현 -&gt; 테스트 -&gt; 배포 형태로 계속해서 반복&lt;/p&gt;
&lt;p&gt;주기적으로 프로토타입을 시험해보는 개발 방법론이라 할 수 있으며 끊임없이 개발하고 수정하는 일을 반복하면서 소비자의 니즈를 가장 만족할 수 있는 방향으로 소프트웨어를 개발한다.&lt;/p&gt;
&lt;p&gt;수정사항 발생시에 즉각적으로 대체가 가능하지만 문서화가 힘들다는 특징이 있다.(너무 난잡해질 가능성도..)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;참고로 아래의 TDD, DDD들은 애자일 방식 중 하나이다.&lt;/p&gt;
&lt;h3&gt;2. TDD(Test-driven development)&lt;/h3&gt;
&lt;p&gt;TDD란 ‘테스트 주도 개발’ 이라고 한다. 반복 테스트를 이용한 소프트웨어 방법론으로, 작은 단위의 테스트 케이스를 작성하고 이를 통과하는 코드를 추가하는 단계를 반복하여 구현한다. 짧은 개발 주기의 반복에 의존하는 개발 프로세스이며 애자일 방법론 중 하나이다.&lt;/p&gt;
&lt;img src=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FmG0Pb%2FbtqBZMj04hL%2FiFrPHyeudxXYfxkWANylY0%2Fimg.png&quot; width=&quot;400&quot;&gt;
&lt;p&gt;개발 주기는 다음과 같다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;테스트 코드를 먼저 작성한다.&lt;/li&gt;
&lt;li&gt;테스트 코드를 성공시키기 위한 실제 코드를 작성한다.&lt;/li&gt;
&lt;li&gt;중복 코드 제거 및 일반화 등의 리팩토링을 수행한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;일반 개발과 다른점은 개발 후 테스트인 일반 개발과 달리 테스트를 먼저 한 후 개발을 한다는 점이 다르다.&lt;/p&gt;
&lt;p&gt;이런 TDD의 장점은&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;높은 코드 안정성&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;테스트 코드 개발-리팩토링 단계를 거치며 끊임 없이 보완하고 종속성과 의존성이 낮은 모듈로 조합된 개발을 가능하게 하여 코드의 안정성을 높일 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;완성도 높은 설계&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;TDD는 설계 단계에서 테스트 시나리오를 작성하기 때문에 무엇을 해야하는 지 미리 정의할 수 있어 완성도 높은 설계로 이어진다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;디버깅 시간의 단축&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;TDD의 경우 자동화된 단위테스트를 통해 특정 버그를 쉽게 찾을 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;물론 단점도 존재한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;생산성의 저하가 크다. 매번 코드를 짤때 개발 코드를 두번 이상 반복해야 함으로 개발의 시간 자체가 늘어날 수 밖에 없다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;3. DDD(Domain Driven Design)&lt;/h3&gt;
&lt;p&gt;DDD란 ‘도메인 주도 설계’로 말 그대로 도메인(문제의 영역)을 중심으로 설계해 나가는 방법이다.&lt;/p&gt;
&lt;p&gt;때문에 일반적으로 많이 사용하는 데이터 중심의 접근법이 아닌 순수한 도메인의 모델과 로직에 집중하는것이 핵심이다.&lt;/p&gt;
&lt;p&gt;이를 위해 유비쿼터스 등의 보편적인 언어를 사용하고 모두가 이해 가능하도록 문서 및 코드가 동일한 표현 및 단어로 구성된다.&lt;/p&gt;
&lt;p&gt;또한 도메인 모델부터 코드까지 항상 함께 움직이는 구조의 모델을 지향한다.&lt;/p&gt;
&lt;p&gt;장점.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;소프트웨어 라이프사이클동안 커뮤니케이션이 원할하다.&lt;/li&gt;
&lt;li&gt;모듈화/캡슐화 기반으로 유연성 향상된다.&lt;/li&gt;
&lt;li&gt;현재 상황에 적합한 소프트웨어 개발론이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;단점.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;도메인이 중요하다 보니 도메인 전문가 참여가 필수적이다.&lt;/li&gt;
&lt;li&gt;기존 도메인의 관행을 개선하기 어렵다.&lt;/li&gt;
&lt;li&gt;기술적으로 복잡한 프로젝트에는 적절하지 않을 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;4. BDD(Behaviour-Driven Development)&lt;/h3&gt;
&lt;p&gt;‘행동 주도 개발’로써 TDD에서 파생된 개발 방법론으로 사용자의 행위를 작성하고 결과 검증을 진행하며 BDD로 테스트 코드를 작성함에 따라 설계 역시 행위의 중심이 되는
도메인 기반 설계이다.&lt;/p&gt;
&lt;img src=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbtBAfj%2FbtrdzN9xM0x%2FbRxcLzqcVEj4nqKyRffGuK%2Fimg.png&quot; width=&quot;400&quot;&gt;
&lt;p&gt;개발 주기는 다음과 같다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;시나리오 상에서 환경을 정의한다.&lt;/li&gt;
&lt;li&gt;사용자가 어떤 행위를 하는 것을 정의한다.&lt;/li&gt;
&lt;li&gt;그에 따른 어떠한 결과를 정의한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;예시로 다음을 들 수 있다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;사용자가 계산기로 ‘1’과 ’+‘와 ‘1’을 누르고 ’=’ 을 누르면 ‘2’라는 숫자가 화면에 정상적으로 나오는지를 테스트&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;그럼 TDD와의 다른점이 뭐냐? TDD는 세부적인 모든 사항들을 테스트한다. 사용자가 계산기에서 ’+‘만 20번 누르는 것도 테스트 하는 것이지만 BDD는 큰 ’=’ 클릭시에 결과가 잘 나오는 가 같은 큰 줄기의 테스트를 진행한다.&lt;/p&gt;
&lt;p&gt;즉, TDD와는 별개가 아닌 얽혀있는 개발 방법론이다.(아마 같이 쓰는 경우가 많지 않을까 싶다.)&lt;/p&gt;
&lt;p&gt;장점.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TDD에 비해 테스트 케이스가 줄어들기에 일정관리와 리소스 관리가 용이하다.&lt;/li&gt;
&lt;li&gt;기획서 요구사항이 곧 테스트 케이스이기에 기획서를 더 중요시하게 되고 기획서에서 놓친 부분에 대한 리스크를 감소시킨다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;5. FDD(Feature Driven Development)&lt;/h3&gt;
&lt;p&gt;기능 위주 개발 방법론으로 개발을 상품이나 서비스 단위가 아니라 신규 기능 단위로 하는 개발 방법론이다.&lt;/p&gt;
&lt;p&gt;특징으로는 여러 개발팀이 있을 경우, 하나의 신규 기능을 개발하기 위해서 전체 팀에서 필요한 내용을 중재하기 위한 프로젝트와 전체 시스템 흐름을 정의할 수 있는 아키텍트의 역할이 필요하게 된다.&lt;/p&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;h3&gt;생활은 과감한 모험이거나 아니면 아무것도 아니다. –헬렌 켈러(Helen Keller)&lt;/h3&gt;
&lt;p&gt;Life is either a daring adventure or nothing at all.&lt;/p&gt;
&lt;/blockquote&gt;</content:encoded></item><item><title><![CDATA[Architecture 디자인 패턴 정리]]></title><description><![CDATA[Architecture 디자인 패턴 정리 평소 디자인 패턴에 관심은 있었는데 자세히 다뤄볼 기회가 없어서서 이번에는 일반적으로 개발시 사용하는 디자인 패턴과 flutter 개발시에 자주 사용되는 디자인 패턴을 기록해볼려 한다. 1. MVC(Model…]]></description><link>https://bosoek.github.io/architecture_design_patterns/</link><guid isPermaLink="false">https://bosoek.github.io/architecture_design_patterns/</guid><pubDate>Mon, 17 Oct 2022 10:00:00 GMT</pubDate><content:encoded>&lt;hr&gt;
&lt;h1&gt;Architecture 디자인 패턴 정리&lt;/h1&gt;
&lt;p&gt;평소 디자인 패턴에 관심은 있었는데 자세히 다뤄볼 기회가 없어서서 이번에는 일반적으로 개발시 사용하는 디자인 패턴과 flutter 개발시에 자주 사용되는 디자인 패턴을 기록해볼려 한다.&lt;/p&gt;
&lt;h3&gt;1. MVC(Model-View-Controller)&lt;/h3&gt;
&lt;p&gt;가장 기본적이고 단순하여 널리 사용되는 디자인 패턴이다.&lt;/p&gt;
&lt;img src=&quot;https://developer.mozilla.org/en-US/docs/Glossary/MVC/model-view-controller-light-blue.png&quot; width=&quot;400&quot;&gt;
&lt;h4&gt;구조&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Model : 데이터와 비즈니스 로직을 관리
&lt;blockquote&gt;
&lt;p&gt;앱이 사용하는 데이터를 가지고 있고 이를 뷰에게 전달해준다. 데이터 수정시에도 뷰에게 알리며 컨트롤러에게 알릴 수도 있다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;View : 레이아웃과 화면을 처리
&lt;blockquote&gt;
&lt;p&gt;모델에게 표시할 데이터를 받아 사용자에게 보여준다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;Controller : 명령을 모델과 뷰 부분으로 라우팅
&lt;blockquote&gt;
&lt;p&gt;사용자의 입력에 대해 모델/뷰를 업데이트 한다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;동작 방식&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;사용자가 항목 추가/삭제 버튼을 누르면 Controller에게 전송된다.&lt;/li&gt;
&lt;li&gt;Controller서 Model을 추가/삭제 처리한다.&lt;/li&gt;
&lt;li&gt;바뀐 데이터를 뷰에서 새롭게 받아서 사용자에게 표시한다.
&lt;blockquote&gt;
&lt;p&gt;이 과정에서 Model을 수정하지 않고 Controller에서 바로 처리도 가능하다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;특징&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;단순하고 직관적이다.&lt;/li&gt;
&lt;li&gt;기능 별로 코드를 분리하여 가독성과 코드 재사용성이 증가한다.&lt;/li&gt;
&lt;li&gt;View와 Model 사이의 &lt;strong&gt;의존성이 높다&lt;/strong&gt;(둘중 하나가 바뀌면 나머지가 먹통이 될 수도 있음)&lt;/li&gt;
&lt;li&gt;View와 Model의 높은 의존성으로인해 서비스가 커질수록 복잡해지고, 유지보수가 어렵다&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;2. MVP(Model-View-Presenter)&lt;/h3&gt;
&lt;p&gt;MVC 패턴과 Model과 View는 같지만, Controller 대신 Presenter가 존재한다.&lt;/p&gt;
&lt;img src=&quot;https://images.velog.io/images/bang/post/bc4ddaaa-64e7-4052-a657-beb97d05b556/mvp.png&quot; width=&quot;400&quot;&gt;
&lt;h4&gt;구조&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Model : 데이터와 비즈니스 로직을 관리
&lt;blockquote&gt;
&lt;p&gt;앱이 사용하는 데이터를 가지고 있다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;View : 레이아웃과 화면을 처리
&lt;blockquote&gt;
&lt;p&gt;사용자에게 UI를 보여주며 MVC와 달리 직접 사용자의 입력을 받는다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;Presenter : 사용자의 입력을 받고 처리하는 부분
&lt;blockquote&gt;
&lt;p&gt;View에서 입력을 받으면 Presenter를 통해 Model을 업데이트하고 다시 Presenter를 거쳐 View를 업데이트한다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;동작 방식&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;사용자가 항목 추가/삭제 버튼을 누르면 View에 사용자 인터렉션이 들어온다.&lt;/li&gt;
&lt;li&gt;View는 Presenter에 인터렉션을 전달한다.&lt;/li&gt;
&lt;li&gt;Presenter는 View 인터렉션대로 Model을 구성/수정한다.&lt;/li&gt;
&lt;li&gt;Update된 Presenter의 데이터를 View에 업데이트 한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;특징&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Presenter가 View &amp;#x26; Model을 이어주는 역할을 한다.&lt;/li&gt;
&lt;li&gt;뷰와 모델의 의존성이 없다(둘중 하나가 바뀌어도 나머지는 영향 X)&lt;/li&gt;
&lt;li&gt;뷰와 Presenter의 의존성이 높아지게 된다.&lt;/li&gt;
&lt;li&gt;앱이 커지며 Presenter의 크기가 비대해져서 시간적 절약 부분에 있어서 손해를 볼 수도 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;3. MVVM(Model-View-ViewModel)&lt;/h3&gt;
&lt;p&gt;MVC 패턴과 Model과 View는 같지만, Controller 대신 Presenter가 존재한다.&lt;/p&gt;
&lt;img src=&quot;https://blog.kakaocdn.net/dn/I0Ia7/btrEaN93m03/QvgBPWN6BlfR7dcRQ9g2a0/img.jpg&quot; width=&quot;400&quot;&gt;
&lt;h4&gt;구조&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Model : 데이터와 비즈니스 로직을 관리&lt;/li&gt;
&lt;li&gt;View : 레이아웃과 화면을 처리&lt;/li&gt;
&lt;li&gt;ViewModel : View에서 필요한 데이터를 처리&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;동작 방식&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;사용자가 항목 추가/삭제 버튼을 누르면 View에 사용자 인터렉션이 들어온다.&lt;/li&gt;
&lt;li&gt;View는 ViewModel로 인터렉션을 전달한다.&lt;/li&gt;
&lt;li&gt;ViewModel은 Model에 데이터를 요청하여 처리하고 저장한다&lt;/li&gt;
&lt;li&gt;View는 직접 ViewModel과의 데이터 바인딩을 통해 View를 업데이트한다.
&lt;blockquote&gt;
&lt;p&gt;이때 ViewModel은 View에 직접 데이터를 전달하지 않는다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;특징&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;View와 Presenter 사이의 의존관계가 1:1인 MVP와 달리, MVVM은 View와 ViewModel사이의 관계가 1대N으로 되어있다.&lt;/li&gt;
&lt;li&gt;데이터 바인딩을 이용한다면 View와 ViewModel 사이의 의존성을 없앨 수 있다.&lt;/li&gt;
&lt;li&gt;테스트 및 확장 용이성이 증가한다.&lt;/li&gt;
&lt;li&gt;ViewModel의 설계가 쉽지 않다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;4. BLoC(Bussiness Logic Component)&lt;/h3&gt;
&lt;p&gt;플러터 개발시에 많이 사용되는 디자인 패턴이다.&lt;/p&gt;
&lt;img src=&quot;https://www.kowanas.com/coding/wp-content/uploads/sites/5/2020/11/image-2.png&quot; width=&quot;500&quot;&gt;
&lt;h4&gt;구조&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Model : 데이터와 비즈니스 로직을 관리&lt;/li&gt;
&lt;li&gt;View : 레이아웃과 화면을 처리&lt;/li&gt;
&lt;li&gt;ViewModel : View에서 필요한 데이터를 처리&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;동작 방식&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;사용자가 항목 추가/삭제 버튼을 누르면 View에 사용자 인터렉션이 들어온다.&lt;/li&gt;
&lt;li&gt;View는 ViewModel로 인터렉션을 전달한다.&lt;/li&gt;
&lt;li&gt;ViewModel은 Model에 데이터를 요청하여 처리하고 저장한다&lt;/li&gt;
&lt;li&gt;View는 직접 ViewModel과의 데이터 바인딩을 통해 View를 업데이트한다.
&lt;blockquote&gt;
&lt;p&gt;이때 ViewModel은 View에 직접 데이터를 전달하지 않는다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;특징&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Presenter가 View &amp;#x26; Model을 이어주는 역할을 한다.&lt;/li&gt;
&lt;li&gt;뷰와 모델의 의존성이 없다(둘중 하나가 바뀌어도 나머지는 영향 X)&lt;/li&gt;
&lt;li&gt;뷰와 Presenter의 의존성이 높아지게 된다.&lt;/li&gt;
&lt;li&gt;앱이 커지며 Presenter의 크기가 비대해져서 시간적 절약 부분에 있어서 손해를 볼 수도 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;View와 Presenter 사이의 의존관계가 1:1인 MVP와 달리, MVVM은 View와 ViewModel사이의 관계가 1대N으로 되어있다.&lt;/li&gt;
&lt;li&gt;데이터 바인딩을 이용한다면 View와 ViewModel 사이의 의존성을 없앨 수 있다.&lt;/li&gt;
&lt;li&gt;테스트 및 확장 용이성이 증가한다.&lt;/li&gt;
&lt;li&gt;ViewModel의 설계가 쉽지 않다.&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;h3&gt;인생에서 많은 패배에 직면하겠지만 결코 패배하지 말라. –마야 안젤루(Maya Angelou)&lt;/h3&gt;
&lt;p&gt;You will face many defeats in life, but never let yourself be defeated.&lt;/p&gt;
&lt;/blockquote&gt;</content:encoded></item><item><title><![CDATA[Newmorphism]]></title><description><![CDATA[Newmorphism 현재 핏메이트 MVP2 디자인이 나왔다. 디자인을 리뉴얼하면서 뉴모피즘 디자인을 적용시키자는 팀 의견이 나와서 뉴모피즘 기반의 디자인으로 리뉴얼을 진행할텐데 뉴모피즘에 대해 간단히 알아보고 구현을 기록하려고 한다.…]]></description><link>https://bosoek.github.io/flutter_neumorphism/</link><guid isPermaLink="false">https://bosoek.github.io/flutter_neumorphism/</guid><pubDate>Thu, 15 Sep 2022 10:00:00 GMT</pubDate><content:encoded>&lt;hr&gt;
&lt;h1&gt;Newmorphism&lt;/h1&gt;
&lt;p&gt;현재 핏메이트 MVP2 디자인이 나왔다. 디자인을 리뉴얼하면서 뉴모피즘 디자인을 적용시키자는 팀 의견이 나와서 뉴모피즘 기반의 디자인으로 리뉴얼을 진행할텐데 뉴모피즘에 대해 간단히 알아보고 구현을 기록하려고 한다.&lt;/p&gt;
&lt;h4&gt;1. Newmorphism이란?&lt;/h4&gt;
&lt;p&gt;실물과 가깝게 디자인하는 스큐어모피즘이라는 디자인의 나은 버전이다.&lt;/p&gt;
&lt;p&gt;기존의 스큐어모피즘은 디테일이 요구되어 작업 속도가 느리고, 사용자의 시선을 분산시키는 문제점이 있어서 스큐어모피즘의 3차원을 2차원으로 단순화하여 심플한 디자인으로 사용자가 보기 편하게 만든것이다.&lt;/p&gt;
&lt;p&gt;참고로 뉴모피즘에 유리 느낌을 더하면 글래스모피즘이 된다. 뉴모피즘과 다른점은 투명도가 강조됐다는 점 정도..?&lt;/p&gt;
&lt;h4&gt;2. Newmorphism의 특징&lt;/h4&gt;
&lt;p&gt;뉴모피즘 특징은 객체와 배경의 구분을 그림자와 빛만으로 하며, 둥글둥글하고 부드러운 인상을 준다. 전체적으로 UI가 생동감 넘치며, 단순 그래픽을 넘어 UI가 촉각적으로 다가오고 약간 미래적인 느낌이 추가된다.(이 부분들이 핏메이트에서 튜모피즘을 채택한 이유)&lt;/p&gt;
&lt;p&gt;물론 단점도 있는데 내용이 많으면 전체적인 가독성이 떨어지고, 빛과 그림자로 객체를 구분하기에 디자인 영역이 커지고 이로 인해 인터페이스 배치가 방해될 수도 있다.&lt;/p&gt;
&lt;h4&gt;4. Newmorphism 구현&lt;/h4&gt;
&lt;p&gt;뉴모피즘은 구현이 크게 어렵지 않다. &lt;code class=&quot;language-text&quot;&gt;boxshadow&lt;/code&gt;만 잘 쓰면 된다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;Container(
   width: 100,
   height: 100,
   decoration: BoxDecoration(
      borderRadius: BorderRadius.circular(50),
      color: Color(0xFFF2F3F7),
      boxShadow: [
         BoxShadow(
         color: Color(0xFFffffff),
         spreadRadius: 2,
         blurRadius: 8,
         offset: Offset(-2, -2),
         ),
         BoxShadow(
         color: Color.fromRGBO(55, 84, 170, 0.1),
         spreadRadius: 2,
         blurRadius: 2,
         offset: Offset(2, 2),
         ),
      ],
   ),
),&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;img src=&quot;https://user-images.githubusercontent.com/68007145/206332809-5fba1b35-9f64-4371-9eea-db02d0337b3c.png&quot; width=&quot;400&quot;&gt;
&lt;p&gt;핵심은 그림자 두개를 대각선으로 반대되게 배치하는 것이다.&lt;/p&gt;
&lt;p&gt;하얀색 그림자를 왼쪽 위에, 검은색 그림자를 오른쪽 아래에 둠으로써 입체감을 느낄 수 있도록 만드는 것이 핵심이다. 막상 해보니 구현은 어렵지 않다. 그럼 이제 버튼 클릭 효과를 구현해보자.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;GestureDetector(
   onTap: () async {
      setState(() {
         click = !click;
      });
      await Future.delayed(Duration(milliseconds : 80),() {
         setState(() {
         click = !click;
         });
      });
   },
   child: AnimatedContainer(
      duration: Duration(milliseconds : 80),
      curve: Curves.fastOutSlowIn,
      width: 100,
      height: 100,
      decoration: BoxDecoration(
         borderRadius: BorderRadius.circular(50),
         color: Color(0xFFF2F3F7),
         boxShadow: click ? null : [
         BoxShadow(
            color: Color(0xFFffffff),
            spreadRadius: 2,
            blurRadius: 8,
            offset: Offset(-2, -2),
         ),
         BoxShadow(
            color: Color.fromRGBO(55, 84, 170, 0.1),
            spreadRadius: 2,
            blurRadius: 2,
            offset: Offset(2, 2),
         ),
         ],
      ),
   ),
),&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;버튼 클릭 시의 시간은 사용자가 보기 답답하지 않으면서도 들어갔다 나오는 효과를 인지할 수 있도록 80 milliseconds가 적당한것 같다.&lt;/p&gt;
&lt;p&gt;글래스 모피즘의 경우 pub.dev에 패키지가 몇개 있던데 뉴모피즘은 간단해서 그런지 pub.dev에 없었다. 나중에 클릭효과 반응 속도를 올리거나 long tap 등의 케이스 처리를 해서 패키지로 만들어 올려도 괜찮을 것 같다.&lt;/p&gt;
&lt;h4&gt;5. 마치며&lt;/h4&gt;
&lt;p&gt;개인적으로 디자인에 관심이 많고 이런 새로운 디자인들을 접하고 시도하는걸 좋아하는 편이다.&lt;/p&gt;
&lt;p&gt;하지만 동시에 사람들이 실제로 사용하기에는 많이 부담스럽고 보기 간편하지 않을 지도 모르겠다는 생각이 든다. 추후 프로젝트에서는 좀 더 디자인 선택을 신중히 해야 할 것 같다.&lt;/p&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;h3&gt;콘셉트가 형태보다 중요하다. -리히하르트 후텐(Richhard Houten)&lt;/h3&gt;
&lt;p&gt;Concept is more important than form&lt;/p&gt;
&lt;/blockquote&gt;</content:encoded></item><item><title><![CDATA[Flutter 페이지 전환에 대한 고찰]]></title><description><![CDATA[Flutter 페이지 전환에 대한 고찰 현재 운영중인 Fitmate의 네비게이터 구조까지 발전하게된 과정들을 기록해볼까 한다. 현업자분들에게는 당연한 부분일 수 있겠지만 나의 경우 삽질을 하면서 스스로 깨달은 부분중 하나이기에 잊고 싶지 않다.…]]></description><link>https://bosoek.github.io/flutter_page_navigator/</link><guid isPermaLink="false">https://bosoek.github.io/flutter_page_navigator/</guid><pubDate>Wed, 10 Aug 2022 10:00:00 GMT</pubDate><content:encoded>&lt;hr&gt;
&lt;h1&gt;Flutter 페이지 전환에 대한 고찰&lt;/h1&gt;
&lt;p&gt;현재 운영중인 Fitmate의 네비게이터 구조까지 발전하게된 과정들을 기록해볼까 한다.&lt;/p&gt;
&lt;p&gt;현업자분들에게는 당연한 부분일 수 있겠지만 나의 경우 삽질을 하면서 스스로 깨달은 부분중 하나이기에 잊고 싶지 않다.&lt;/p&gt;
&lt;h4&gt;1. Fitmate의 메인 화면들&lt;/h4&gt;
&lt;p&gt;초기 핏메이트는 기획부터 메인 화면이(하단 네비게이터에 있는 페이지 수가) 5개였다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;홈화면&lt;/li&gt;
&lt;li&gt;채팅목록&lt;/li&gt;
&lt;li&gt;지도&lt;/li&gt;
&lt;li&gt;달력&lt;/li&gt;
&lt;li&gt;프로필&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;당연히 이때는 각 페이지에 대한 깊은 생각은 없었고 가장 기본적인 네비게이터를 사용하여 페이지 전환을 했다.(&lt;del&gt;이때는 플러터를 시작한지도 얼마 되지 않았었다&lt;/del&gt;)&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;Navigator.push(
   context,
   MaterialPageRoute(
      builder: (context) =&gt; 화면명()),
)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;하지만 이러한 방식은 첫 배포 이후 이슈로 이어졌다.&lt;/p&gt;
&lt;h4&gt;2. 기존 Navigator의 문제는?&lt;/h4&gt;
&lt;p&gt;기존 Navigator를 사용하는 방식은 첫 문제는 지도 페이지에서 일어났다.&lt;/p&gt;
&lt;p&gt;지도의 경우 네이버 지도 라이브러리를 사용했는데 처음 빌드시에 1-2초 정도가 소요된다. 즉 지도 페이지로 이동할때마다 사용자는 1-2초를 기다려야했다는 거다.&lt;/p&gt;
&lt;p&gt;단순 프로젝트면 아무 문제 될 게 없지만 Fitmate는 이미 출시까지 한 서비스이기에 이런 점은 사용자 경험을 안좋게 만들 수밖에 없다.&lt;/p&gt;
&lt;p&gt;때문에 어떻게 지도 로딩을 줄여야 할지에 대한 고민을 게속 했고, 그 결과 지도 페이지를 살려둘 수 있는 방법을 생각해낸다.&lt;/p&gt;
&lt;img src=&quot;https://blog.kakaocdn.net/dn/b1j1EP/btrAcWiIeeQ/PAUT9taBoi7hkhJh4O5160/img.png&quot; width=&quot;500&quot;&gt;
&lt;p&gt;기본적으로 어플은 스택 구조이다.(&lt;del&gt;이전에 나는 스택 구조인지도 몰랐었다&lt;/del&gt;) 이걸 바탕으로 생각해낸 초기 아이디어는 지도 페이지 이전까지는 Navigator로 이동하고 지도 페이지가 나오면 그 위에 페이지들을 올리고 빼는 것이었다.&lt;/p&gt;
&lt;p&gt;간단히 시나리오를 작성해보자면.&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;사용자는 처음에 홈 화면으로 들어옴 (&lt;strong&gt;push&lt;/strong&gt;, 스택에는 홈화면만)&lt;/li&gt;
&lt;li&gt;사용자가 채팅 페이지로 이동(&lt;strong&gt;push&lt;/strong&gt;, 스택에 홈화면 삭제 후 채팅 화면만)&lt;/li&gt;
&lt;li&gt;사용자가 지도 페이지로 이동(&lt;strong&gt;push&lt;/strong&gt;, 스택에는 지도 페이지만)&lt;/li&gt;
&lt;li&gt;사용자가 홈화면으로 이동(&lt;strong&gt;push&lt;/strong&gt;, 스택에는 지도 - 홈)&lt;/li&gt;
&lt;li&gt;사용자가 채팅 페이지로 이동(&lt;strong&gt;push&lt;/strong&gt;, 스택에는 지도 - 채팅)&lt;/li&gt;
&lt;li&gt;사용자가 지도 페이지로 다시 이동(&lt;strong&gt;pop&lt;/strong&gt;, 스택에는 지도)&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;이런 식으로 스택에 한번 들어오 지도 페이지를 계속 사용해서 지도 페이지 자체의 로딩 시간을 없애는 것이다.&lt;/p&gt;
&lt;p&gt;당시에는 이 방법으로 지도 페이지 로딩 제거에 만족했지만 곧 나는 일반 페이지의 로딩 시간도 없애야 되겠다고 생각했다.&lt;/p&gt;
&lt;h4&gt;3. 일반 페이지들의 로딩&lt;/h4&gt;
&lt;p&gt;분명 내가 나왔던 페이지인데도 로딩하는 것이 이상하고(다른 사용 어플들은 이렇지 않음), 사용자의 입장에서 봤을 때 너무 느렸다.&lt;/p&gt;
&lt;p&gt;하지만 이미 스택상에 살려두는 방법은 썻기 때문에 다른 방법을 생각해야 했고 이번에는 금방 새로운 방법을 떠올렸다.&lt;/p&gt;
&lt;p&gt;처음 열때 서버에서 가져온 데이터들을 저장하고, 사용자가 해당 페이지를 다시 열면 서버에서 새로운 값을 가져오는 동안 기존 값을 보여주고 있는 것이다.&lt;/p&gt;
&lt;p&gt;이번에도 시나리오로 보도록하자.&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;사용자가 홈 화면으로 들어옴&lt;/li&gt;
&lt;li&gt;로딩 화면 출력 후 컨텐츠 나열 - 해당 데이터들은 앱단에 저장&lt;/li&gt;
&lt;li&gt;사용자가 다른 페이지로 이동 후 다시 홈화면으로 옴&lt;/li&gt;
&lt;li&gt;서버에서 값을 가져오며 일단 기존에 가져온 데이터로 컨텐츠 나열 후 서버에서 값이 다 가져와지면 컨텐츠 바꿈&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;해당 방식으로 서버 값 대기에 따른 페이지 로딩을 없앨 수 있었다. 코드상으로는 다음과 같다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;FutureBuilder&amp;lt;List&gt; (
   future: 서버에서 값 가져오는 함수(),
   builder: (context, snapshot) {
      if (snapshot.hasData) {
         snapshot 데이터로 출력
      }
      if(처음 여는 페이지라면) {로딩 화면}
      기존 값 출력
   },
),&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;하지만 이 방법도 곧 또 다른 불편함으로 이어진다.&lt;/p&gt;
&lt;h4&gt;4. 또 다른 불편함?&lt;/h4&gt;
&lt;p&gt;바로 사용자가 보는 와중에 화면이 끊긴다는 것이다.&lt;/p&gt;
&lt;p&gt;즉, 사용자가 기존에 보는 화면을 스크롤 중이라면, 어플이 새로운 서버 값으로 교체함에 따라 다시 스크롤의 맨 위로 화면이 강제 이동 된다. 결국 근본적으로 페이지 자체를 살려 두는 것이 베스트여서 찾아 보고 &lt;code class=&quot;language-text&quot;&gt;AutomaticKeepAliveClientMixin&lt;/code&gt; 등도 사용해봤지만 효과는 없었다.&lt;/p&gt;
&lt;p&gt;때문에 또 며칠을 골머리를 앓고 있었는데, 그때 친구가 나한테 회사 과제 구현하는데 도와달라고 했다. 나는 알겠다고 하고 소스코드를 봐주다가 처음으로 PageView라는 것을 알게되었다. 해당 친구가 내가 생각한 방식으로 사용한 것은 아니지만 pageview와 navigator를 활용하면 처음 생각대로 화면 자체를 저장하는 것이 가능할 것 같았다.&lt;/p&gt;
&lt;p&gt;때문에 바로 검색을 해봤고 역시나 pageview를 사용해 화면 저장이 가능했고 즉시 pageview를 사용하는 형태로 어플을 수정했다. 왜 이전에 검색시에는 pageview 관련은 아무것도 안나왔는지가…&lt;/p&gt;
&lt;p&gt;코드로 확인하면 다음과 같다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;Scaffold(
  extendBody: true,
  body: PageView(
    controller: pageController,
    onPageChanged: onPageChanged,
    children: [
      페이지 목록들
    ],
    physics: NeverScrollableScrollPhysics(), // No sliding
  ),
  bottomNavigationBar: child: BottomNavigationBar(
              elevation: 10,
              backgroundColor: whiteTheme,
              showSelectedLabels: false,
              showUnselectedLabels: false,
              type: BottomNavigationBarType.fixed,
              onTap: (int index) {
                pageController.jumpToPage(index);
              },
              currentIndex: _currentIndex,
              items: [
                BottomNavigationBarItem(
                  icon: SvgPicture.asset(
                          // 5
                          &quot;${iconSource}home_icon.svg&quot;,
                          width: iconSize,
                          height: iconSize,
                        ),
                  label: &apos;Home&apos;,
                ),
                BottomNavigationBarItem(
                  icon: SvgPicture.asset(
                          // 5
                          &quot;${iconSource}chatting_icon.svg&quot;,
                          width: iconSize,
                          height: iconSize,
                        ),
                  label: &apos;Chatting&apos;,
                ),
        ]),
);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;페이지 목록들과 BottomNavigationBarItem의 수만 일치시키면 되며, 각 페이지 클래스들은 &lt;code class=&quot;language-text&quot;&gt;with AutomaticKeepAliveClientMixin&lt;/code&gt; 를 붙여야한다.&lt;/p&gt;
&lt;h4&gt;5. 마치며&lt;/h4&gt;
&lt;p&gt;어쩌면 나의 이 고민들이 남들 눈에는 뻘짓으로 보일지도 모르겠다.&lt;/p&gt;
&lt;p&gt;하지만 나에게는 개발중에 생긴 문제를 포기하지 않고 끝까지 잡고 늘어졌고, 틀린 방식이라곤 해도 나만의 방식으로 조금씩 해결해나갔다는 점이 중요했고, 그 때문에 가장 기본적인 내용이지만 글로 남기고 싶었다.&lt;/p&gt;
&lt;p&gt;앞으로도 개발중에 적어도 문제를 포기하는 것만큼은 하고 싶지 않다.&lt;/p&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;h3&gt;혁신을 시도하다보면 실수를 할 때가 있다. 빨리 실수를 인정하고, 당신의 다른 혁신들을 서둘러 개선해나가야 한다. -스티브 잡스(Steven Jobs)&lt;/h3&gt;
&lt;p&gt;Sometimes when you innovate, you make mistakes. It is best to admit them quickly, and get on with improving your other innovations.&lt;/p&gt;
&lt;/blockquote&gt;</content:encoded></item><item><title><![CDATA[Flutter 개발 시의 이슈들]]></title><description><![CDATA[Flutter 개발 시의 이슈들 플러터 개발시에 자주 생기는 오류들, 배포시에 발생하는 이슈들을 정리한다 1. Exception caught by widgets library Container 사용시에 decoration을 안쓴다면 바로 color…]]></description><link>https://bosoek.github.io/flutter_issue/</link><guid isPermaLink="false">https://bosoek.github.io/flutter_issue/</guid><pubDate>Mon, 01 Aug 2022 10:00:00 GMT</pubDate><content:encoded>&lt;hr&gt;
&lt;h1&gt;Flutter 개발 시의 이슈들&lt;/h1&gt;
&lt;p&gt;플러터 개발시에 자주 생기는 오류들, 배포시에 발생하는 이슈들을 정리한다&lt;/p&gt;
&lt;h3&gt;1. Exception caught by widgets library&lt;/h3&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;Cannot provide both a color and a decoration
To provide both, use &quot;decoration: BoxDecoration(color: color)&quot;.
&apos;package:flutter/src/widgets/container.dart&apos;:
Failed assertion: line 273 pos 15: &apos;color == null || decoration == null&apos;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Container 사용시에 decoration을 안쓴다면 바로 color를 지정해도 되지만 decoration 속성 사용시에는 반드시 decoration 안에 색을 지정해야한다.&lt;/p&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;h3&gt;나는 실패한 게 아니고, 다만 전구가 안되는 이치를 발견했을 뿐이다. -토머스 에디슨(Thomas Edison)&lt;/h3&gt;
&lt;p&gt;I didn’t fail, I just found out that the light bulb didn’t work.&lt;/p&gt;
&lt;/blockquote&gt;</content:encoded></item><item><title><![CDATA[Flutter 인터뷰 정리]]></title><description><![CDATA[Flutter 인터뷰 정리 올해 진행된 소프트웨어 마에스트로(SW Maestro.) 과정에 운좋게 선정되었는데 팀 내에서 Flutter 개발을 담당하게 될 것 같아 우선 먼저 Flutter…]]></description><link>https://bosoek.github.io/flutter_interview/</link><guid isPermaLink="false">https://bosoek.github.io/flutter_interview/</guid><pubDate>Fri, 06 May 2022 10:00:00 GMT</pubDate><content:encoded>&lt;hr&gt;
&lt;h1&gt;Flutter 인터뷰 정리&lt;/h1&gt;
&lt;p&gt;올해 진행된 소프트웨어 마에스트로(SW Maestro.) 과정에 운좋게 선정되었는데 팀 내에서 Flutter 개발을 담당하게 될 것 같아 우선 먼저 Flutter에 대해 공부하려고 한다.&lt;/p&gt;
&lt;p&gt;작년에 공부한 내용 복습겸 기본적인 개념 이해 겸 해서 작성하는 글!&lt;/p&gt;
&lt;h4&gt;1. 플러터(Flutter)란?&lt;/h4&gt;
&lt;p&gt;Google에서 개발한 Flutter는 크로스 플랫폼 모바일 앱 개발 프레임워크이다. 여기서 &lt;strong&gt;크로스 플랫폼&lt;/strong&gt; 이란 하나의 프레임워크로(언어로) 안드로이드, IOS 모두 개발 가능한 것을 의미하며, Flutter의 경우 웹과 데스크탑 앱도 개발 가능하다.(이게 내가 Flutter를 선택한 이유이다)&lt;/p&gt;
&lt;h4&gt;2. 플러터의 장점은?&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;코드 개발 감소 : Flutter의 핫 리로드 기능을 통해 더 빠른 성능을 제공한다. 이를 통해 응용 프로그램은 arm C/C++ 라이브러리를 사용하여 컴파일되어 기계 코드에 더 가까워지고 더 빠르게 실행 가능하다.&lt;/li&gt;
&lt;li&gt;교차 플랫폼 개발 : Flutter를 사용하면 여러 플랫폼에서 코드를 작성하고 관리하고 실행할 수 있다.&lt;/li&gt;
&lt;li&gt;라이브 및 핫 리로딩 : 앱 개발 프로세스를 더 간단하고 빠르게 만든다.&lt;/li&gt;
&lt;li&gt;네이티브 앱 성능과 유사 : 대부분의 크로스 플랫폼 프레임워크와 달리 Flutter는 중간 코드 표현이나 해석에 의존하지 않는다. Flutter 애플리케이션은 기계 코드에 직접 내장되어 해석 프로세스와 관련된 성능 문제를 제거합니다.(물론 네이티브보다 성능이 더 좋지는 못한다.)&lt;/li&gt;
&lt;li&gt;좋은 커뮤니티 지원 : 개발자는 문제에 대해 질문하고 신속하게 답변을 얻을 수 있습니다.(하지만 아직 커뮤니티가 작은것도 사실이다.)&lt;/li&gt;
&lt;li&gt;문서:  Flutter의 문서는 정말 잘 정리되어있고 친절하다. 내가 본 문서중에서도 탑급이다.&lt;/li&gt;
&lt;li&gt;표현력 있고 유연한 UI : Flutter는 고도로 사용자 정의 가능한 디자인, 표현력이 풍부한 UI 및 빠른 렌더링을 허용하는 다양한 아키텍처를 제공한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;3. 플러터 아키텍쳐를 설명하시오&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;상위 계층 : 앱 위젯, 제스처, 애니메이션, 일러스트레이션 및 자료를 관리하는 Dart 기반 플랫폼&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Flutter 엔진 : 텍스트의 표시 및 서식 지정을 처리&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;빌트인 서비스 : 플러그인, 패키지, 이벤트 루프 관리에 사용됨.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;4. 플러터의 중요한 특징들&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;유연성, 확장성 및 통합: Flutter의 사용하기 쉽고 통합하기 쉬운 프레임워크는 향상된 유연성, 확장성 및 통합 기능을 제공&lt;/li&gt;
&lt;li&gt;핫 리로드: 개발자가 코드를 수정하면 핫 리로드로 변경 사항을 즉시 확인할 수 있다.&lt;/li&gt;
&lt;li&gt;원스톱 솔루션: Flutter 앱 개발은 개발, 배포 및 관리를 위한 단일 프레임워크와 플랫폼에 의존한다.&lt;/li&gt;
&lt;li&gt;기본 성능 및 국제화된 Flutter 라이브러리: Flutter 앱 개발은 Android, iOS 및 Google Fuchsia용으로 맞춤화된 위젯을 제공하며 위젯을 사용하면 스크롤, 내비게이션, 아이콘, 글꼴 등 플랫폼의 모든 기능이 통합가능하다.&lt;/li&gt;
&lt;li&gt;거대한 위젯 라이브러리: 거의 모든것이 위젯인 Flutter, 위젯이 겁나게 많다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;5. 플러터의 한계&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;라이브러리의 제한 : Flutter는 비교적 새롭기 때문에 타사 라이브러리에 비해 수가 적다.&lt;/li&gt;
&lt;li&gt;릴리스 크기가 더 큼 : 확실히 릴리즈의 용량이 큰편이다.&lt;/li&gt;
&lt;li&gt;Dart의 요구 사항 : Flutter를 위해 족보도 없는 Dart를 공부해야 한다.(하지만 다트 문법 자체가 여러 언어 짬뽕이라 큰 단점이라 느끼지는 않았다.)&lt;/li&gt;
&lt;li&gt;복잡성 제한 : Flutter의 3D 모델링, Unity 통합 및 게임 엔진이 부족하고 대부분의 광고 모바일 플랫폼도 지원하지 않습니다.&lt;/li&gt;
&lt;li&gt;전반적인 지원 부족 : Flutter는 아직 널리 사용되지 않고있다. 기술 애호가들의 관심을 받고 있지만 시간이 지남에 따라 제공될 지속적인 지원은 여전히 ​​부족한 상황&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;6. 플러터의 빌드시 모드들의 차이&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;디버그 모드 : 이 모드에서는 물리적 장치, 에뮬레이터 또는 시뮬레이터에서 앱을 디버깅할 수 있으며 어설션 및 서비스 확장이 여기에서 활성화됩니다.&lt;/li&gt;
&lt;li&gt;프로필 모드 : 이 모드에서는 테스트하는 동안 앱의 성능을 분석하기에 충분한 디버깅 기능이 유지되며 추적 및 일부 확장이 활성화됩니다. 에뮬레이터 및 시뮬레이터에서는 해당 동작이 실제 성능을 재현하지 않기 때문에 프로필 모드가 비활성화된다. &lt;code class=&quot;language-text&quot;&gt;flutter run --profile&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Release Mode : 앱을 배포할 때 Footprint의 크기를 최소화하고 최적화를 최대화하기 위해 이 모드를 사용하며 디버깅, 어설션 및 서비스 확장이 비활성화된다. &lt;code class=&quot;language-text&quot;&gt;flutter run --release&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;7. 플러터의 위젯의 중요성을 설명하세요.&lt;/h4&gt;
&lt;p&gt;일반적으로 Flutter 앱은 여러 위젯으로 구성됩며 보이는 부분은 거의 다 위젯이다. 그만큼 위젯의 활용법이 무궁무진하다.&lt;/p&gt;
&lt;h4&gt;8. 플러터 위젯의 종류는 무엇인가요.&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Stateless Widget : 본질적으로 정적이며 상태를 저장하지 않는다. 따라서 변경될 수 있는 값을 저장하지 않는다.&lt;/li&gt;
&lt;li&gt;Stateful Widget : 상태 저장 위젯은 본질적으로 동적이므로 변경 사항을 모니터링하고 이에 따라 UI를 업데이트할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;9. Dart의 중요성과 의미는 무엇인가요.&lt;/h4&gt;
&lt;p&gt;Google에서 개발한 프로그래밍 언어인 Dart는 Flutter 앱과 서버 및 데스크톱 애플리케이션을 코딩하는 데 사용된다. Flutter는 Dart를 사용하여 JSX 또는 XML과 같은 별도의 선언적 레이아웃 언어를 사용하지 않는다.&lt;/p&gt;
&lt;h4&gt;10. State에 대해서 설명하세요.&lt;/h4&gt;
&lt;p&gt;state는 공유 상태 또는 애플리케이션 상태라고도 하며, 앱 섹션 간에 앱 상태를 공유하고 동일한 방식으로 사용자 세션을 유지할 수 있습니다.&lt;/p&gt;
&lt;h4&gt;11.  runApp()과 main()의 차이는 무엇인가요.&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;main(): 프로그램의 최초 시작점이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;runApp(): runApp()을 사용하면 화면에 렌더링될 위젯 트리의 루트로 화면에 연결된 위젯을 반환할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;12. 플러터에서의 Package와 plugins를 설명하세요.&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;플러그인: 네이티브 코드를 사용하여 사용성을 높이고 장치를 더 쉽게 사용할 수 있다.&lt;/li&gt;
&lt;li&gt;패키지:  dart 프로그래밍 언어로 작성된 새로운 코드 또는 구성 요소이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;13. 플러터 개발을 위한 에디터는 무엇이 있나요?&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;안드로이드 스튜디오 - 1순위 인것 같다.&lt;/li&gt;
&lt;li&gt;비주얼 스튜디오&lt;/li&gt;
&lt;li&gt;IntelliJ IDEA&lt;/li&gt;
&lt;li&gt;Xcode&lt;/li&gt;
&lt;li&gt;Emacs&lt;/li&gt;
&lt;li&gt;Eclipse&lt;/li&gt;
&lt;li&gt;Vim 등&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;14. 플러터를 사용한 유명한 앱들은 무엇이 있나요?&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Google Ads&lt;/li&gt;
&lt;li&gt;Alibaba&lt;/li&gt;
&lt;li&gt;Tencent&lt;/li&gt;
&lt;li&gt;국내에는 스타트업 위주로 사용되는 중&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;15. 플러터에서 Key는 무슨 뜻인가요? 언제 사용해야 하나요?&lt;/h4&gt;
&lt;p&gt;키는 Flutter에서 위젯, 요소 및 시맨틱 노드의 식별자로 사용되며 GlobalKeys 및 LocalKeys는 Key의 하위 클래스이다. 위젯 트리 내에서 키는 수정된 위젯의 상태를 유지하는 역할을 하고, 키를 사용하면 동일한 유형 및 정의된 상태가 있는 위젯 모음을 재구성하고 수정할 수도 있다.&lt;/p&gt;
&lt;h4&gt;16. Container 위젯을 설명하세요&lt;/h4&gt;
&lt;p&gt;가장 만만한 위젯으로 하위 위젯 수용, 크기, 패딩, 마진, 색, 모양 등등 거의 제약 없이 사용 가능하며 어떤 위젯 써야 할 지 모르겠다 싶을때 쓰는 위젯이다.(거의 다 가능)&lt;/p&gt;
&lt;h4&gt;17. 플러터와 리액트네이티브중 무엇이 더 훌륭한가요?&lt;/h4&gt;
&lt;p&gt;어떤 것이 더 훌륭하냐는 질문은 답이 없는 질문이다. 사람에 따라 답이 달라지기 때문.&lt;/p&gt;
&lt;p&gt;최대한 객관적으로 말하자면 현재는 react native가 우세라고 생각한다. 하지만 이미 커뮤니티나 관심도 수치는 플러터가 리엑트를 뛰어 넘었고 몇년 뒤면 플러터가 대세로 사용될거라 생각된다.&lt;/p&gt;
&lt;h4&gt;18. mainAxisAlignment 와 crossAxisAlignment는 언제 사용하나요?&lt;/h4&gt;
&lt;p&gt;행, 열에 대한 정렬을 정의하는 속성이다.&lt;/p&gt;
&lt;p&gt;행의 경우:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;mainAxisAlignment = 가로 축&lt;/li&gt;
&lt;li&gt;crossAxisAlignment = 세로 축&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;열의 경우:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;mainAxisAlignment = 세로 축&lt;/li&gt;
&lt;li&gt;crossAxisAlignment = 가로 축&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;19. 왜 플러터앱은 개발 기간이 긴가요?&lt;/h4&gt;
&lt;p&gt;Flutter 애플리케이션을 처음 빌드할 때 Flutter가 기기별 IPA 또는 APK 파일을 생성하므로 평소보다 훨씬 오래 걸린다. Xcode와 Gradle을 사용하여 일반적으로 시간이 많이 걸리는 파일을 빌드합니다.&lt;/p&gt;
&lt;h4&gt;20. 플러터 Inspector에 대해 설명하세요.&lt;/h4&gt;
&lt;p&gt;Android와 마찬가지로 XML 파일을 통해 앱의 청사진 및 속성을 볼 수 있다. 위젯과 그 속성의 청사진을 시각화할 수 있는 Flutter 애플리케이션용 Flutter Inspector라는 강력한 도구가 있으며 이를 활용하여 다양한 레이아웃 문제를 진단하고 현재 레이아웃을 이해할 수 있습니다.&lt;/p&gt;
&lt;p&gt;Flutter Inspector는 다음과 같은 이점:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;위젯 모드 선택&lt;/li&gt;
&lt;li&gt;플랫폼 전환&lt;/li&gt;
&lt;li&gt;페인트 기준선 표시&lt;/li&gt;
&lt;li&gt;디버그 페인트 표시&lt;/li&gt;
&lt;li&gt;새로 고침 위젯&lt;/li&gt;
&lt;li&gt;느린 애니메이션 활성화&lt;/li&gt;
&lt;li&gt;성능 오버레이 표시/숨기기&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;21. 플러터 Ticker의 용도는 무엇인가요?&lt;/h4&gt;
&lt;p&gt;Flutter에서 애니메이션이 얼마나 자주 새로고침되는지 알려주기 위해 티커를 사용한다.&lt;/p&gt;
&lt;h4&gt;22. 디버그 모드에서만 코드를 실행하는 방법은 무엇인가요.&lt;/h4&gt;
&lt;p&gt;아래 코드를 통해 디버그서버/릴리즈 서버를 구분하여 개발을 진행하기도 한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;import &apos;package:flutter/foundation.dart&apos; as Foundation;    

The next step is to use kReleaseMode as follows: 

if (Foundation.kReleaseMode){     // is Release Mode??   
   print(&apos;release mode&apos;);   
} else {   
             print(&apos;debug mode&apos;);   
}    
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;23. Mixins의 용도&lt;/h4&gt;
&lt;p&gt;거지같은 Dart는 다중 상속을 지원하지 않는다. 따라서 Flutter/Dart에서 다중 상속을 구현할 때 믹스인이 사용된다.&lt;/p&gt;
&lt;h4&gt;24. Stream은 무슨 뜻인가요?&lt;/h4&gt;
&lt;p&gt;비동기 프로그래밍에서 스트림은 비동기 방식으로 데이터 시퀀스를 제공하는 데 사용된다. 파이프와 마찬가지로 한쪽 끝에 값을 입력하면 청취자가 다른 쪽 끝에 값을 받는 형태고, 여러 수신기를 하나의 스트림에 넣을 수 있으며 파이프라인에 넣을 때 모두 동일한 값을 얻는다. SteamController를 통해 스트림을 만들고 관리할 수 있습니다.&lt;/p&gt;
&lt;h4&gt;25. Streams의 유형은 무엇인가요?&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;단일 구독 스트림 : 이 스트림은 이벤트를 순차적으로 전달한다. 더 큰 전체 내에 포함된 시퀀스로 간주되며, 이러한 스트림은 파일 읽기와 같이 이벤트가 수신되는 순서가 중요한 경우에 사용된다.&lt;/li&gt;
&lt;li&gt;브로드캐스트 스트림 : 이 스트림은 구독자에게 이벤트를 전달한다. 이벤트를 구독하면 구독자는 즉시 이벤트를 들을 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;26. Flutter SDK는 무슨 뜻인가요?&lt;/h4&gt;
&lt;p&gt;Flutter SDK(소프트웨어 개발 키트)를 사용하면 개발자가 단일 코드 베이스를 사용하여 모바일, 웹 및 데스크톱용 애플리케이션을 빌드할 수 있다.&lt;/p&gt;
&lt;h4&gt;27. Hot reload와 Hot restart의 차이는 무엇인가요.&lt;/h4&gt;
&lt;p&gt;다트 응용 프로그램의 경우 초기 실행에는 상당한 시간이 필요하다. 따라서 이 문제를 해결하기 위해 flutter에는 Hot Reload와 Hot Restart라는 두 가지 기능이 있어 앱을 실행한 후 실행 시간을 줄여준다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Hot Reload : 기능을 수행하는 데 약 1초가 걸리는 Flutter의 뛰어난 기능. 이 기능을 사용하면 쉽고 빠르게 변경, 버그 수정, UI 생성 및 기능 추가가 가능하다. 핫 리로드 기능을 활용하여 새 코드를 파일로 빠르게 컴파일하고 DVM(Dart Virtual Machine)으로 보낼 수 있다. DVM이 업데이트를 완료하는 즉시 앱의 UI를 업데이트합니다.&lt;/li&gt;
&lt;li&gt;핫 리스타트 : 핫 리로드와 비교하여 기능이 약간 다르다. 여기에서 앱의 보존 상태가 파괴되고 코드가 처음부터 다시 컴파일된다. 핫 리로드보다 시간이 오래 걸리지만 전체 재시작 기능보다 빠르다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;28. BuildContext에 대해서 설명하세요.&lt;/h4&gt;
&lt;p&gt;BuildContext는 위젯 트리에서 위젯을 식별하거나 찾는 데 사용된다. 각 위젯에는 자체 BuildContext, 즉 위젯당 하나의 BuildContext가 있습니다. 이를 활용하여 위젯 부모와 상호 작용하고 위젯 데이터에 액세스할 수 있다.&lt;/p&gt;
&lt;h4&gt;29. Widget Testing 은 무엇인가요?&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;단위 테스트 : 단위 테스트를 사용하면 클래스나 메서드를 테스트할 수 있다. 다만 단위 테스트는 화면 렌더링, 외부 서비스와의 상호 작용 또는 사용자 상호 작용을 확인하지 않는다.&lt;/li&gt;
&lt;li&gt;위젯 테스트 : 위젯 테스트를 사용하면 단일 위젯을 테스트할 수 있다. 이렇게 하면 위젯의 UI가 예상대로 표시되고 이벤트에 적절하게 응답한다. 즉, 위젯 디자인, 렌더링 및 다른 위젯과의 상호 작용이 기준에 부합하는지 확인하는 테스트이다.&lt;/li&gt;
&lt;li&gt;통합 테스트 : 통합 테스트를 사용하면 전체 앱의 중요한 흐름을 테스트할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;30. 상태관리란 무엇인가요?&lt;/h4&gt;
&lt;p&gt;상태 관리는 매우 중요합니다. 이를 사용하면 다양한 UI 컨트롤의 상태가 중앙 집중화되어 애플리케이션 전체의 데이터 흐름을 처리할 수 있다. (텍스트 필드, 라디오 버튼, 체크박스, 드롭다운, 토글, 양식 등등)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Ephemeral State: 임시 상태는 UI 상태 또는 로컬 상태라고도 하며 특정 위젯과 관련됨. 즉, 특정 위젯 내에 포함된 상태이며 StatefulWidget을 통해 Flutter는 이 상태를 지원한다.&lt;/li&gt;
&lt;li&gt;App State: 앱의 여러 부분에서 공유하고 세션 간에 유지하려는 상태이므로 임시 상태와 다르다. 따라서 이러한 유형의 상태는 전역적으로 사용 가능하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;31. pubspec.yaml 파일에 대해서 설명하세요.&lt;/h4&gt;
&lt;p&gt;‘pubspec’이라고도 하는 pubspec.yaml 파일은 Flutter 프로젝트를 만들 때 포함되는 파일로 프로젝트 트리의 맨 위에 위치한다. 이 파일에는 프로젝트에 필요한 패키지 및 해당 버전, 글꼴 등과 같은 종속성에 대한 정보가 포함되며 다음에 프로젝트를 빌드할 때 동일한 패키지 버전을 얻게 됩니다.&lt;/p&gt;
&lt;p&gt;이 파일에는 다음이 포함되어 있습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;프로젝트 이름, 버전, 설명 등과 같은 일반 프로젝트 설정&lt;/li&gt;
&lt;li&gt;프로젝트 내의 종속성.&lt;/li&gt;
&lt;li&gt;프로젝트 자산(예: 이미지, 오디오 등).&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;32. Tween Animation에 대해서 어떻게 이해하고 있나요?&lt;/h4&gt;
&lt;p&gt;애니메이션의 시작과 끝점은 트윈 애니메이션에서 지정하면 애니메이션이 시작 부분에서 시작하여 끝점에 도달할 때까지 일련의 값을 통해 진행할 수 있다. 전환 속도와 기간도 트윈 애니메이션을 사용하여 결정된다.&lt;/p&gt;
&lt;h4&gt;33. 플러터에서 주로 사용되는 Database packages 두가지는 무엇인가요?&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;Firebase 데이터베이스 : 사용자에게 클라우드 데이터베이스에 대한 액세스 및 제어를 제공. Firebase는 기본적으로 JSON 프로토콜을 통해 데이터 검색 및 저장을 관리할 수 있는 Flutter 앱용 NoSQL 데이터베이스를 제공한다. 데이터 동기화 및 빠른 로딩은 Flutter 앱에 가장 적합한 옵션 중 하나입니다.&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;NoSQL DB&lt;/li&gt;
&lt;li&gt;API(REST만 해당)&lt;/li&gt;
&lt;li&gt;입증&lt;/li&gt;
&lt;li&gt;해석학&lt;/li&gt;
&lt;li&gt;저장&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;SQFlite 데이터베이스 : 사용자는 이를 사용하여 SQLite 데이터베이스에 액세스하고 수정할 수 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;서버리스&lt;/li&gt;
&lt;li&gt;제로 구성&lt;/li&gt;
&lt;li&gt;오픈 소스&lt;/li&gt;
&lt;li&gt;콤팩트&lt;/li&gt;
&lt;li&gt;단일 DB 파일&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h4&gt;34. 플러터 Provider에 대해 설명하세요.&lt;/h4&gt;
&lt;p&gt;Provider는 위젯을 사용하여 구축됨. Flutter가 생성하는 새 위젯 하위 클래스가 있는 Flutter의 일부인 것처럼 Provider의 모든 객체를 사용할 수 있다. Provider는 상태 관리를 처리하는 가장 간단한 방법.(그 외에 GetX, BLoC)&lt;/p&gt;
&lt;h4&gt;35. Await는 무엇인가요?&lt;/h4&gt;
&lt;p&gt;async 메서드가 완료될 때까지 await는 프로세스 흐름을 중단한다. 대기는 일반적으로 반환 값을 얻을 수 있도록 이 함수가 완료될 때까지 대기를 의미. 대기는 비동기와 함께만 사용할 수 있다.&lt;/p&gt;
&lt;p&gt;장점: 네이티브를 몰라도 앱을 만들 수 있다&lt;/p&gt;
&lt;p&gt;단점: 네이티브를 알아야 했다.&lt;/p&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;h3&gt;리엑트 네이티브의 장점은 네이티브를 몰라도 앱을 만들 수 있지만, 단점은 네이티브를 알아야 했다는 것이다. -???&lt;/h3&gt;
&lt;p&gt;The advantage of React Native is that you can create apps without knowing native, but the downside is that you had to know native.&lt;/p&gt;
&lt;/blockquote&gt;</content:encoded></item><item><title><![CDATA[세일즈 클로징(Secrets of closing the sale)]]></title><description><![CDATA[세일즈 클로징(Secrets of closing the sale…]]></description><link>https://bosoek.github.io/closing/</link><guid isPermaLink="false">https://bosoek.github.io/closing/</guid><pubDate>Sun, 27 Mar 2022 10:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;세일즈 클로징(Secrets of closing the sale)&lt;/h1&gt;
&lt;p&gt;최근 창업을 준비하면서 여러 공부들을 병행하고 있는데 창업시 마케팅과 세일즈 기술은 어느 분야에서나 쓰인다고 생각하여 관련 책 시리즈를 읽고 있다. 그중 첫번째 책이 세일즈 클로징이다.&lt;/p&gt;
&lt;p&gt;세일즈 클로징은 &lt;strong&gt;지그 지글러(Zig Ziglar)&lt;/strong&gt; 라는 세일즈계의 전설적인 인물이 쓴 책으로써 관련 분야에서는 꽤 유명한 책이었다.&lt;/p&gt;
&lt;p&gt;지그 지글러는 이 책을 설명식으로 쓰여졌고 700개의 질문, 200여가지의 테크닉, 세일즈 전략들이 적혀있는 세일즈 실전용 지침서라고 했으며 여러번 반복하여 읽기를 권장하였다.&lt;/p&gt;
&lt;img src=&quot;https://user-images.githubusercontent.com/68007145/160277232-bc453cd6-eea7-48f5-8c43-e46877531551.jpg&quot; width=&quot;500&quot;&gt;  
&lt;p&gt;책은 처음부터 이목을 확 끌면서 시작한다. 첫번째 에피소드가 바로 지그 지글러의 아내분이 새로운 집을 사자고 설득하는 이야기 였는데 이 아내분이 마지막에 하는 제안과 가장 마지막에 &lt;code class=&quot;language-text&quot;&gt;행복한 아내를 위해 하루에 1달러를 쓸수 있어?&lt;/code&gt; 라고 묻는 말이 굉장히 신선했다.&lt;/p&gt;
&lt;p&gt;이 에피소드에서 기존 문제와 새로운 문제를 분리시키기, 문제를 작게 나누어 다루기, 상대가 원하는 이미지로 보여주기 등 여러 세일즈 기술이 나온다. 아마 세일즈에 관심 없는 사람이라도 이 에피소드만으로 충분히 이 책에 빠질 거 같을 정도로 너무 재밌는 에피소드였다.&lt;/p&gt;
&lt;img src=&quot;https://user-images.githubusercontent.com/68007145/166227580-e3510033-0195-4b83-953e-f1d3aca0d157.jpg&quot; width=&quot;500&quot;&gt;
&lt;p&gt;책에서는 동기부여나 의욕을 일으키는 영상 및 음악을 들으라고 권장하고 있다. 나도 평소에 진로에 대한 회의감이 생길때 유튜브에서 동기부여 영상들을 보는 편인데 앞으로는 조금 더 자주 들어야 겠다는 생각이 들었다.&lt;/p&gt;
&lt;p&gt;또한 아침에 음악을 들으라는 부분도 나한테는 중요한 점이라고 생각이 들었다. 학교에서는 아침에 음악을 틀어주지만 집에서는 아침에 음악을 안듣는다. 학교와 집에서의 공부 효율을 생각해 봤을때 아침에 음악을 듣는 것이 나한테는 더 잘 맞는 것 같다.&lt;/p&gt;
&lt;img src=&quot;https://user-images.githubusercontent.com/68007145/166227626-be5d71f0-c5ee-4c23-9b75-874556c673c3.jpg&quot; width=&quot;600&quot;&gt;  
&lt;p&gt;내가 이 책에서 두번째로 좋아하는 에피소드이다. 사례가 극단적이긴 하지만 동시에 세일즈라는 것이 뭔지에 대해 가장 직관적으로 이야기하는 에피소드라고 생각한다.&lt;/p&gt;
&lt;p&gt;결국 서비스의 목적은 사용자에게 필요한 솔루션을 제공하는 것이고, 세일즈의 목적은 &lt;strong&gt;솔루션이 왜 필요한지&lt;/strong&gt; 에 대해 설명하는 것이라고 생각한다. 그런 점에서 짧은 에피소드만으로 자신들과 거리가 멀다고 생각한 보험을 병사들이 &lt;strong&gt;이해 가능한 영역까지&lt;/strong&gt; 가져오고 나아가 병사들이 왜 꼭 사야하는지로써 설명하는 부분이 세일즈 방식에 대해 새로운 시각을 제시하는 것 같았다.&lt;/p&gt;
&lt;img src=&quot;https://user-images.githubusercontent.com/68007145/166227713-ce2c83ab-ab24-4bf3-bfc9-1e35798937df.jpg&quot; width=&quot;500&quot;&gt;  
&lt;p&gt;이 파트는 내가 세일즈 만이 아닌 소통에서는 제일 중요하다고 생각하는 &lt;strong&gt;질문&lt;/strong&gt; 에 대한 부분이었다.&lt;/p&gt;
&lt;p&gt;질문은 &lt;code class=&quot;language-text&quot;&gt;네 생각은 어때?&lt;/code&gt; 등으로 팀원의 참여를 도울 수 있고 날카로운 지적을 받았을 때 &lt;code class=&quot;language-text&quot;&gt;그럼 ... 부분에 대해서 혹시 아실까요? 실제 ... 통계에 따르면....&lt;/code&gt;처럼 역으로 질문을 한 다음 흐름을 유도할 수 도 있다.&lt;/p&gt;
&lt;p&gt;이처럼 내가 소통의 기술로써 중요하게 생각하는 질문을 어떤 케이스에서 어떤 테크닉으로 사용해야 할지가 위의 파트 외에도 책 전반에서 다양하게 나와서 좋았다.&lt;/p&gt;
&lt;img src=&quot;https://user-images.githubusercontent.com/68007145/166227780-c88d6586-39a0-4809-8e15-d7f39b708992.jpg&quot; width=&quot;600&quot;&gt;  
&lt;p&gt;지글러님은 책에서 확신에 대해서도 이야기 하고 있다. 세일즈맨의 상품에 대한 확신을 대화를 통해 고객도 느낀다는 것이었는데 보고 가장 먼저 든 생각이 &lt;strong&gt;일론 머스크&lt;/strong&gt; 같은 사람도 처음에는 스포츠 전기차라는 허무맹랑한 아이템을 본인의 확신으로 밀어붙여 결국 성공했다는 점이었다.&lt;/p&gt;
&lt;p&gt;또 확신을 가져야 한다는 점이 비단 세일즈에서만 쓰이는 것이 아닌 삶 전체에서의 가치관에도 적용된다고 생각이 들어 나만의 신념과 나 자신에 대한 확신을 가져야 겠다는 생각이 들었다.&lt;/p&gt;
&lt;p&gt;책이 전반적으로 실전 지침서라는게 이해될만큼 어마어마한 에피소드와 개념들을 담았다는걸 알 수 있었고 여러번 읽으며 개념들을 익히면 실전에서도 정말 유용할 거 같다는 생각이 들었다.&lt;/p&gt;
&lt;p&gt;또한 세일즈가 단순 판매할 때 만이 아닌 기업에게 &lt;code class=&quot;language-text&quot;&gt;나&lt;/code&gt;의 가치를 파는 취준생, 환자에게 &lt;code class=&quot;language-text&quot;&gt;약&lt;/code&gt;의 가치를 설명하는 의사등 사회 전반에서 사용될 수 있다는 생각이 들어 꼭 세일즈 업계 사람이 아니라도 한번쯤은 추천해 주고 싶은 책이었다.&lt;/p&gt;
&lt;img src=&quot;https://user-images.githubusercontent.com/68007145/160277190-c7edf28a-4241-4c1b-93a8-46c5cd2df1a3.jpg&quot; width=&quot;600&quot;&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;h3&gt;나무를 베는 데 9시간이 주어진다면 그중 6시간은 도끼를 가는 데 쓰겠다. -아브라함 링컨(Abraham Lincoln)&lt;/h3&gt;
&lt;p&gt;If I had 9 hours to chop down a tree, I would spend 6 of those hours sharpening an axe.&lt;/p&gt;
&lt;/blockquote&gt;</content:encoded></item><item><title><![CDATA[1년 안에 AI 빅데이터 전문가가 되는 법(How to become an AI big data expert within a year)]]></title><description><![CDATA[1년 안에 AI 빅데이터 전문가가 되는 법(How to become an AI big data expert within a year…]]></description><link>https://bosoek.github.io/ai_big_data/</link><guid isPermaLink="false">https://bosoek.github.io/ai_big_data/</guid><pubDate>Sun, 20 Feb 2022 10:00:00 GMT</pubDate><content:encoded>&lt;hr&gt;
&lt;h1&gt;1년 안에 AI 빅데이터 전문가가 되는 법(How to become an AI big data expert within a year)&lt;/h1&gt;
&lt;p&gt;한양대학교 정보시스템학과를 전공하고 추천 알고리즘, 이상탐지, 프로세스 마이닝, 이미지 처리 등을 연구하며 빅데이터 분석 회사 다겸의 대표로 재직중이신 &lt;strong&gt;서대호&lt;/strong&gt; 님이 집필한 책이다.&lt;/p&gt;
&lt;p&gt;서대호 님이 빅데이터를 공부한 방식, 프리랜서로써 인공지능 개발자가 근무하는 방법, 본인의 성장 과정부터 그 과정에서 가진 생각들을 작성하셨다.&lt;/p&gt;
&lt;img src=&quot;https://user-images.githubusercontent.com/68007145/155574425-0c08b518-ee6f-4106-9083-1ae0ff46511d.jpg&quot; width=&quot;500&quot;&gt;  
&lt;p&gt;책의 초반 부분에서 가장 돋보이는 부분이 &lt;strong&gt;AI 빅데이터 전문가로써 경력을 쌓아가는 방법&lt;/strong&gt; 이었다. 처음에 보고 든 생각은 참 놀라울 정도로 나랑 반대구나 라는 생각이 들었다. 대부분의 내용인 SNS를 통한 본인의 마케팅인데, 나는 온라인 커뮤니티에 많이 가입은 되어 있지만 활동은 거의 안하기 때문이었다.&lt;/p&gt;
&lt;p&gt;때문에 귀찮더라도 지금 내가 가입해 있는 카카오톡 단톡방, 페이스북에 자주 글을 올리며 사람들에게 나를 알려야 겠다는 생각이 들었다.&lt;/p&gt;
&lt;p&gt;또한 서대호 님의 대학 생활도 상당히 흥미로웠다.&lt;/p&gt;
&lt;img src=&quot;https://user-images.githubusercontent.com/68007145/155575505-a4e53a2a-0891-4be0-b43d-c101efbe8fbe.jpg&quot; width=&quot;500&quot;&gt;
&lt;p&gt;나같아도 전공과 취직에 집중하느라 다른 것들은 눈이 안갔을 텐데, 오히려 서대호 님은 다른 다양한 일들을 접하는 것에 집중하였다는것이 독특했다. 실제로 서대호 님은 대학원에서 AI 빅데이터 공부를 시작하였는데 이 선택과 이후의 사업으로써의 성공에 다양한 분야들을 경험한 것이 도움이 되었을 것 같다는 생각이 들었다.&lt;/p&gt;
&lt;p&gt;현재 나도 생명공학부터 기계 공학까지 단순한 AI 개발자가 아닌 더 많은 것들을 공부하고 경험해 보고 싶다는 생각이 있다. 하지만 취직이라는 마이스터고의 특성에 나도 모르게 그런 생각들을 접게 되었던 것 같았다. 나도 아직은 젊고 하고 싶은 것들이 많기에, 여러 가지들을 경험해 봐야 겠다고 생각이 들었다.&lt;/p&gt;
&lt;h2&gt;논문&lt;/h2&gt;
&lt;p&gt;책에서 많이 강조하는 것중 하나이면서 AI 전문가가 되기 위한 필수 요소로 서대호 님이 말하는 것이 논문이다.&lt;/p&gt;
&lt;img src=&quot;https://user-images.githubusercontent.com/68007145/155576697-ddf30af5-e60f-4a99-8261-941358f650cd.jpg&quot; width=&quot;600&quot;&gt;
&lt;p&gt;여러 분야의 정보들이 하루에도 수없이 쏟아지는 현재에 책은 수많은 자료, 검증 및 시간이 걸리지만 논문은 매우 빠르게 올라올 수 있어 최신 기술 습득을 위해서는 필수적으로 논문을 읽어야 한다고 말한다.&lt;/p&gt;
&lt;p&gt;솔직히 나는 책과 커뮤니티 코드를 위주로 공부를 하고 있어서 개념적인 심화 부분까지는 미흡했다. 다행히 책에서 논문들을 얻는 방법과 사이트 등을 알려줘서 관련 논문들부터 공부해 봐야겟다는 생각이 들었다.&lt;/p&gt;
&lt;h2&gt;프리랜서&lt;/h2&gt;
&lt;p&gt;책의 중요 부분중 또 다른 하나가 프리랜서 부분이였다. 서대호 님은 책의 많은 내용들을 굳이 취직을 할 필요가 없다와 프리랜서로써의 성장 과정들로 적어놓으셨다.&lt;/p&gt;
&lt;img src=&quot;https://user-images.githubusercontent.com/68007145/155577908-75d85ca4-c94e-46c4-a5fa-1d53e04e75eb.jpg&quot; width=&quot;500&quot;&gt;
&lt;p&gt;실제로 서대호 님은 회사 대표직과 4개 회사의 사원 직무를 동시에 수행하고 계신다. 이게 가능한 이유는 바로 재택 근무와 마케팅이었다. AI 분야는 사실상 데이터 전처리, 시각화, 모델 생성, API 배포까지 혼자 도맡아 하는 경우가 많고 혼자 하는 경우가 더 편하고 빠른 경우가 많다.&lt;/p&gt;
&lt;p&gt;이에 굳이 회사에 가지 않고 재택근무로 시간을 효율화 시키고 자신을 온라인에서 마케팅하여 기업들이 &lt;strong&gt;나&lt;/strong&gt; 를 찾게 만드는 것이 비결이라고 하셨다.&lt;/p&gt;
&lt;p&gt;프리랜서 파트는 나에게는 꽤나 근사하고 재밌었다. 일단 나는 현재 창업을 목표로 하고 있지만 그 전에 돈을 버는 것이 기본이였다. 재택을 통한 여러 직무 소화와 그 다음인 프리랜서로써의 활동은 창업 활동 중에도 가능한 일인거 같아 현재는 관련 나도 온라인 활동들을 시작했다.&lt;/p&gt;
&lt;p&gt;또한 서대호님의 방식대로 따라한 후배가 1년만에 프리랜서로써 월 3000을 번다는 말이 있어 나도 노력해보면 할 만 하다는 생각이 들었다.&lt;/p&gt;
&lt;h2&gt;마치며&lt;/h2&gt;
&lt;p&gt;여러모로 재밌는 구간이 많은 책이었던 것 같다. 특히나 단순한 개발 부분만이 아닌 공부 방법, 사업적인 관점부터, 관련 도서 추천까지 올인원이 가능하였고 다양한 생각들을 할 수 있게 하고 동기부여까지 부여해 준 것 같아 나에게는 더 잘 맞았던 책이었다.&lt;/p&gt;
&lt;p&gt;당연히 세상 모두가 서대호님처럼 프리랜서로써 성공할 수는 없을 것이다. 하지만 누구든 자신만의 속도로 그 발걸음을 따라가다 보면 언젠가는 그들을 따라잡을 수 있을 거라고 믿는다. 그렇기에 지금 해야 할 것은 고민이 아닌 행동이라고 생각한다.&lt;/p&gt;
&lt;img src=&quot;https://user-images.githubusercontent.com/68007145/155522583-2513cbb8-6ebd-4ff8-a7b8-de52fa042b42.jpg&quot; width=&quot;600&quot;&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;h3&gt;난 두려울 때마다 ‘난 미친놈이다’, ‘난 대단하다’, ‘난 똑똑하다’ 라고 외친다. -서대호&lt;/h3&gt;
&lt;p&gt;Whenever I’m scared, I shout, “I’m crazy”, “I’m amazing”, “I’m smart”.&lt;/p&gt;
&lt;/blockquote&gt;</content:encoded></item><item><title><![CDATA[제13기 소프트웨어 마에스트로 서류 합격 자소서]]></title><description><![CDATA[제13기 소프트웨어 마에스트로 서류 합격 자소서 1. 소프트웨어분야 전문성을 키우기 위해 남들과 달리 특별한 노력을 한 경험을 서술하라. 고등학교에 입학 후…]]></description><link>https://bosoek.github.io/sw_maestro/</link><guid isPermaLink="false">https://bosoek.github.io/sw_maestro/</guid><pubDate>Thu, 17 Feb 2022 10:00:00 GMT</pubDate><content:encoded>&lt;hr&gt;
&lt;h1&gt;제13기 소프트웨어 마에스트로 서류 합격 자소서&lt;/h1&gt;
&lt;h2&gt;1. 소프트웨어분야 전문성을 키우기 위해 남들과 달리 특별한 노력을 한 경험을 서술하라.&lt;/h2&gt;
&lt;p&gt;고등학교에 입학 후 1학년에는 정보처리 기능사를 취득하며 컴퓨터의 기본적인 지식을 습득하였고, 그 후에 인공지능 프로그래밍을 실질적으로 공부하기 위해서 IT 교육 학원이나 외부 기관에서 진행하는 강의를 찾아다니면서 공부했습니다. 처음으로는 2020 인공지능 사관학교 온라인 강좌를 이수하며 인공지능의 기본 지식을 학습하였고 해당 과정을 이수하였습니다. 하지만 해당 과정의 난이도가 입문자가 이해하기에는 너무 어렵다는 평이 많았고 좀 더 개념적인 학습이 필요하다고 생각이 들어 서울 ICT 이노베이션 스퀘어의 인공지능 NLP 고급 과정을 수료하면서 NLP의 기본과 간단한 챗봇 프로젝트를 진행하며 공부하였습니다. 그 외에도 NIPA의 AI 온라인 실무 기본 &amp;#x26; 응용 과정을 이수하며 데이터 분석 능력을 길렀습니다.. 해당 과정들을 통해서 기본 개념들부터 차근차근 이해할 수 있었고, 이론 뿐만 아니라 실제적인 문제 해결을 위한 프로젝트를 통해 인공지능 모델을 설계하고 이를 다룰 수 있는 능력을 길렀습니다.&lt;/p&gt;
&lt;p&gt;기본적인 인공지능 개념을 공부한 후에는 프로젝트와 커뮤니티를 찾아 다녔습니다. 특히 처음으로 현업 사람들과 협업한 Klue Baseline(&lt;a href=&quot;https://pseudo-lab.github.io/klue-baseline/&quot;&gt;https://pseudo-lab.github.io/klue-baseline/&lt;/a&gt;) 프로젝트는 Klue 과제를 초보자들이 쉽게 접근할 수 있도록 도우미 페이지를 제작하는 프로젝트 였는데 이때 BERT나 HugingFace를 처음으로 접하고 사용해보며 공부할 수 있었고, 대학생, 직장인 분들등 다양한 직군의 인공지능 개발자 분들과 이야기 해 볼수 있었습니다. 그 후에도 GAN으로 우주 이미지 생성하기 프로젝트나 한국인 감정 인식 경진대회, Kaggle, Dacon등 여러 대회와 프로젝트를 진행 및 참여하면서 인공지능의 여러 분야를 경험해 볼 수 있었고, 그 외에도 학교 홈페이지 제작 프로젝트에서 웹과 백엔드 개발, Fluter 공부등 여러 클라이언트 개발도 경험할 수 있었습니다.&lt;/p&gt;
&lt;p&gt;그후 작년 말에 BMO 프로젝트를 진행 하였습니다. BMO는 대화형 로봇 프로젝트로 speech to speech 대화, 게임, 음악 재생까지 지금껏 공부한 모든 분야가 사용되는 프로젝트 였습니다. 게다가 젯슨 나노와 라즈베리파이를 사용하며 통신 문제, 외관 3D 프린팅 문제, AI 챗봇 제작까지 여러 어려움이 있었지만 팀원들과 3주 동안 데이터 정제, 회로 납땜, 목소리 데이터 수집까지 열심히 노력한 끝에 완성까지는 아니어도 꽤 괜찮은 결과물을 얻을 수 있었고 덕분에 GSM 페스티벌 대회에서 장려상을 수상할 수 있었습니다. 그 후에는 배운 지식들을 정리해야 겠다고 생각이 들어 현재 블로그에서 지금까지 공부했던 지식들을 정리하고 있고 지금은 AI 개발자 네트워크를 조금 더 만들고 싶다는 생각에 현재 가짜 연구소라는 온라인 커뮤니티에서 활동하고 있으며 Data Science Fellowship 과정을 수강하여 datacamp의 강의를 수강하고 있습니다.&lt;/p&gt;
&lt;h2&gt;2. 귀하의 장래희망을 서술하여 주시기 바랍니다.&lt;/h2&gt;
&lt;p&gt;첫번째로 소통하는 인공지능 엔지니어가 되고 싶습니다. 현재도 그렇지만 앞으로는 인공지능이 사용되지 않는 분야가 없을 것입니다. 이런 사회에서 사람들과 소통하며 정말로 사람들에게 필요한 인공지능 서비스를 제공하고 인공지능 엔지니어로써 팀원, 클라이언트, 고객들의 의견과 상황을 반영하며 각각의 사람들과 소통하여 많은 사람들에게 도움을 줄 수 있는 인공지능 엔지니어가 되고 싶습니다.  그리고 더 나아가서는 개발 뿐만 아니라 사업적인 분야에 대한 넓은 시각과 인사이트를 통해 실제 문제를 해결하는 프로젝트를 기획해보고 싶습니다. 특히 제가 관심있어 하는 분야는 챗봇과 Image Detection입니다. 특히나 자연어 처리와 영상, 이미지 처리만큼 인공지능 분야에서 커다란 파이를 차지하고 있는 분야는 없는 만큼 앞으로 메타버스, 게임, 콘텐츠 시장, 로봇 전 분야에 걸쳐 챗봇과 Detection분야는 매우 중요하게 작용할 것이고 이에 따라 많은 사람들에게 도움을 줄 수 있는 서비스를 제공하고 싶습니다.&lt;/p&gt;
&lt;p&gt;두번째로 프로젝트 관리자 입니다. 프로젝트 진행시에 가장 중요한 점은 관리자의 역량이라고 생각합니다. 팀의 전체적인 방향성부터 세부 업무 및 일정까지 많은 일을 하는 자리이지만 또 팀원들과 계속해서 회의하고 소통해야 하는 자리이기도 합니다. 다른사람들과 만나고 이야기하는 것을 좋아하는 개발자로써 소통하는 프로젝트 관리자가 되어 팀을 이끄는 사람이 되고 싶습니다.&lt;/p&gt;
&lt;p&gt;세번째로 창업입니다. 2021년 12월 부터 22년 2월까지 대학생 온라인 멘토링 프로그램에서 창업 관련 멘토링을 진행하였고, 인프런에서 창업 강의를 수강하기도 했으며 개발과는 무관한 분야이긴 하지만 실제로 온라인 마켓을 운영해 본 적이 있습니다. 현재 한국은 창업 지원부터, 멘토링, 펀딩처럼 다양한 창업 지원이 존재하고 있는 만큼 저만의 아이디어를 창업을 통해 꽃피워 보고 싶습니다.&lt;/p&gt;
&lt;h2&gt;3. 어떤 능력을 갖춘 연수생들과 어떤 프로젝트를 어떻게 수행할 것인지 귀하의 구체적인 계획을 서술하여 주시기 바랍니다.&lt;/h2&gt;
&lt;p&gt;저의 메인 분야는 인공지능입니다. 데이터 수집, 데이터 전처리 그리고 모델링 및 API 배포를 담당할 수 있습니다. 그러나 실제로 서비스를 개발하려면 서비스를 구체화 시킬 수 있어야 합니다. Flask와 Django등의 백엔드는 다루어보았지만 프론트엔드 분야 및 앱등을 전적으로 담당하기에는 저의 실력이 부족하기에 이런 클라이언트 영역을 구현해 줄 팀원이 필요합니다. 또 저는 팀원들의 가장 중요한 요소중 하나가 참여성과 적극성이라고 생각합니다. 실제로 참여성이 적으면 개발 역량이 뛰어나도 프로젝트가 흐지부지 되기도 하고 개발 역량이 적어도 적극적이면 금방 배워 팀 전체에 많은 도움이 되기 때문에 협동성과 참여력이 높은 팀원이 필요하다고 생각되고 개발 역량이 비교적 떨어지는 팀원들도 Github, Slack, Notion 등의 온라인 협업 툴을 이용해 프로젝트를 효율적으로 관리하면 충분히 기술적인 커버가 가능하다고 생각합니다. 또한 창업에 관심이 많은 팀원을 선호합니다. 마에스트로 과정에서 창업을 하시는 팀들이 많고 저 또한 창업을 굉장히 희망하기 때문에 창업에 관심 많고 적극적인 팀원분들과 만나길 희망하고 있습니다.&lt;/p&gt;
&lt;p&gt;저의 메인 분야가 인공지능인 만큼 인공지능 관련 프로젝트를 구상 중입니다. 대표적으로는 대화형 챗봇 앱입니다. 시장에 제시된 대부분의 앱들은 채팅을 통한 대화가 메인 콘텐츠입니다. 반면 speech to speech 형태의 대화 앱은 거의 없고 대부분 사용되는 곳들도 인공지능 비서정도입니다. 저는 대화형 로봇 프로젝트(BMO)를 진행한 적도 있고 앱 개발에서 백엔드로 참여한 경력이 있기에 관련 프로젝트로 진행되어도 흥미로운 경험이 될 것 같습니다.&lt;/p&gt;
&lt;h2&gt;4. 연수생에게 교육지원비, 노트북PC 및 프로젝트 재료비 등을 지원할 예정이며, 본인이 희망하는 온라인 강의와 프로젝트 수행을 도와주는 멘토(팀별 5명 내외)를 통해 귀하의 SW능력을 향상·발전 할 수 있는 기회를 제공하고 있습니다. 앞으로 약 6개월간 귀하께서 본 과정을 통해 이루고자하는 목표가 무엇인지 구체적으로 서술하여 주시기 바랍니다.&lt;/h2&gt;
&lt;p&gt;첫번째로 알고리즘과 R, 데이터 분석을 더 공부해 보고 싶습니다. 현재 저는 Python과 C를 주 언어로 사용하고 있습니다. 하지만 데이터 분석 분야에서는 R또한 상당히 많이 사용되고 실재 산업에서도 이용되고 있는 만큼 R언어를 새롭게 공부해 보고 싶고, 현재 leetcode와 백준에서 알고리즘 문제를 풀고 있지만 BFS, DFS같은 기본적인 개념들만 풀 수 있을 정도밖에 안되서 개인적으로 알고리즘 문제 해결 경험 및 능력이 너무 부족하다고 느껴져서 연수 과정동안 알고리즘에 대해 깊이있게 공부하고 싶습니다. 또 데이터 분석을 더 다뤄보고 싶습니다. 데이터 분석에는 시각화, 데이터 마이닝, 탐색적 자료 분석, 공간 분석 등등 정말 다양하고 많습니다. 하지만 지금까지 프로젝트 및 공부를 진행 하며 실제로 사용해 본 것은 시각화 정도 밖에 안되서 여러 데이터 분석을 직접 경험해 보고 싶습니다.&lt;/p&gt;
&lt;p&gt;두번째로 프로젝트를 실제 서비스 운영으로 이어 나가고 싶습니다. 현재까지 학교 소개 웹사이트, 채팅 및 카메라 인식 앱등의 여러 서비스 프로젝트들을 진행 및 참여 해왔지만 해당 프로젝트들은 실제 운영(출시)으로까지 이어진 적이 한번도 없습니다. 대부분은 프로젝트의 성향이 강해 프로젝트가 마무리 되면 잊혀지게 되었습니다. 하지만 개발과 운영은 또 다른 문제라고 생각합니다. 실제 운영에서는 서버, 코드 리펙토링, 새로운 소스 추가등 또 다른 문제들이 발생 할 것이고, 실제로 현업에서도 개발보다 운영적인 측면에 더 많은 시간을 할애하기 때문에 제가 참여한 프로젝트를 실제 서비스 운영으로 이어가며 현업의 운영을 직접 경험해 보고 운영경험을 쌓아보고 싶습니다.&lt;/p&gt;
&lt;p&gt;세번째로 실무 경험과 인적 교류입니다. 마이스터 고등학교의 특성상 같은 또래의 학생들만 접하게 되다 보니 SW마에스트로 과정을 통해 대학생 분이나 현업이셨던 분들과 이야기하고 프로젝트를 진행하며 개발 네트워크를 구축하고 피드백을 받아보고 싶고 또 여러 프로젝트를 진행해보면서 가장 크게 느꼈던 한계점은 기술적인 부분 뿐만 아니라 프로젝트 자체에 대해 저의 경험 부족으로 인해 제한적이고 초보적인 시각을 가지고 있었다는 점입니다. 특히나 프로젝트 주제의 방향성이 명확하게 정해져 있지 않아 불필요한 자원과 시간 낭비를 하며 많은 좌충우돌이 있었습니다. 때문에 정말 실력과 경험이 풍부한 멘토 분들을 통해서 그 분들의 스킬과 인사이트를 배우며 실무 경험을 쌓아 보고 싶고 개발 실력 뿐만 아니라 프로젝트 진행 및 관리 등과 사업적인 관점과 창업적인 면에서 서비스 아이템의 관점 및 생각을 배워보고 싶습니다.&lt;/p&gt;
&lt;h2&gt;5. 추가적인 대회 참여 기록&lt;/h2&gt;
&lt;p&gt;2021 한전 kdn 빛가람 에너지벨리 소프트웨어 경진대회에 참여하여 장려상을 수상했었습니다. 저희 팀은 Medic으로 엔포레스트라는 개발자 커뮤니티 앱을 개발하게 되었고 저는 해당 앱에서 인공지능으로 명찰의 글자를 인식하는 인공지능을 개발하고 API로 배포하는 부분을 담당했었습니다. OCR을 처음 프로젝트로 시도하는 것이라서 OCR의 개념을 처음부터 다시 공부하였고, ai hub의 OCR 데이터 셋으로 모델을 제작한 후 Flask와 google Cloud Platform을 통해 API를 배포했었습니다. 프로젝트를 진행하며 컨셉 변경 부터 AWS 배포가 안되는 등 여러 문제가 있기도 했고 또 팀원들과 팀장의 의견 일치가 안되서 여러 문제가 있었습니다. 그때마다 “우리가 하기로 이미 말 한 만큼 끝까지 해보자”라는 말을 서로에게 해주며 의지를 다시 일으켰고 다행히 한전 kdn 대회에 입상하며 좋은 결과를 거둘 수 있었습니다.&lt;/p&gt;
&lt;p&gt;그후 엔포레스트 앱은 대한민국 소프트웨어 대전에서 저희 학교 이름으로 부스 운영도 하게 되었습니다. 여러 분들에게 저희 앱을 소개하며 좋은 경험을 하였습니다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[멘토링 프로그램을 끝내며]]></title><description><![CDATA[멘토링 프로그램을 끝내며 찬우 형과의 대학생 멘토링 프로그램을 끝내며 남기는 기록 21년도 12월…]]></description><link>https://bosoek.github.io/mentoring_programme/</link><guid isPermaLink="false">https://bosoek.github.io/mentoring_programme/</guid><pubDate>Thu, 10 Feb 2022 10:00:00 GMT</pubDate><content:encoded>&lt;hr&gt;
&lt;h1&gt;멘토링 프로그램을 끝내며&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;찬우 형과의 대학생 멘토링 프로그램을 끝내며 남기는 기록&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;21년도 12월 4일부터 시작한 대학생 멘토링 프로그램이 이번주 일요일을 마지막으로 끝났다. 마이스터고의 특성상 대학 진학과는 거리가 멀 수 밖에 없지만 대학 생활은 어떨지 이야기라도 들어 보고 싶었고, 또 대학 공부도 한번쯤 접해보면 좋겠다는 생각으로 &lt;strong&gt;멘토링 프로그램을 신청&lt;/strong&gt; 했다.&lt;/p&gt;
&lt;p&gt;전공의 경우는 내가 평소에 관심 있었던 기계 공학을 선택했고, 찬우 형과 매칭된 후 오프라인에서 만나기로 약속을 잡았다.&lt;/p&gt;
&lt;h2&gt;첫 만남&lt;/h2&gt;
&lt;p&gt;송정역 근처의 이디야 커피점에서 만났다. 첫시간에는 전공 공부보다는 서로 알아가는 시간이라고 형이 말해서 편하게 나의 대학에 대한 마음이나, 평소에 대학에 대해 &lt;strong&gt;궁금했던 점들&lt;/strong&gt; 을 물어봤다.&lt;/p&gt;
&lt;img src=&quot;https://user-images.githubusercontent.com/68007145/155517285-d3183714-0dba-427a-b70f-04fead829a0b.jpg&quot; width=&quot;600&quot;&gt;
&lt;p&gt;그렇게 두시간 정도를 이야기 하다 보니 많은 사실을 알 수가 있었다. 대학의 기계공학과에서는 실제로 실습은 하지 않고, 이론 수업만 한다는 점, 공립 대학의 경우는 학비가 거의 없다는 점, 또 가장 공감 되었던 말은 다양한 사람들을 만나볼 수 있다는 점이다.&lt;/p&gt;
&lt;p&gt;지금 내가 활동중인 GSM이나 온라인 크루의 경우 개발자들만 모여있다 보니 사고나 상상력이 어느정도 제한된다는 것이 많이 느껴졌었다. 프로젝트 아이디어부터 관심사가 너무 비슷한 사람들만 모이다 보니 새로운 아이템이 나오기가 힘든 구조였다.&lt;/p&gt;
&lt;p&gt;그런 점에서 대학에서 여러 사람들을 접하며 &lt;strong&gt;다양한 생각&lt;/strong&gt; 들을 들어볼 수 있다는 말이 매력적으로 느껴졌다.&lt;/p&gt;
&lt;p&gt;솔직히 대학 진학에는 큰 관심을 두고 있지 않았었는데 첫 만남에서 많은 생각들이 바뀌었다. 이 멘토링을 진행하지 않았더라면 대학에 큰 관심 없이 취직했을 지도 모르는 일이였어서 첫만남이 가장 기억에 남는다.&lt;/p&gt;
&lt;h2&gt;공부와 진로&lt;/h2&gt;
&lt;p&gt;두번째 만남부터는 실제 기계 공학과에서 배우는 기계 역학 이론을 배웠다. 여기서 문제는 내가 재학중인 마이스터고의 커리큘럼상 수학 진도를 고등학교까지 나가지 않았고 따로 수학 공부를 더 하지 않아서 대학 이론 공부를 따라가기가 벅찼다.&lt;/p&gt;
&lt;p&gt;다행히도 형이 내 상황을 배려해 줘서 고등학교 수학과 물리학 공부부터 다시 시작해 보기로 했다.&lt;/p&gt;
&lt;img src=&quot;https://user-images.githubusercontent.com/68007145/155518627-2abe04c5-de8b-49fd-b93c-f965ca30de6d.jpg&quot; width=&quot;600&quot;&gt;
&lt;p&gt;그 외에도 학습지 추천, 읽어 봤으면 하는 교양 책들도 추천해 주었고 진로 상담도 이루어 졌다. 현재 내 상황에서 대학 진학이 가능한지, 진학할 대학 리스트 추리기, 자소서 작성 방법까지 여러 모로 많은 도움을 줬다.&lt;/p&gt;
&lt;p&gt;멘토링 진행 때에는 형도 3학년으로 올라가는 지라 취직 문제를 가지고 있었다 취직을 하는게 좋을지, 아니면 대학원으로 가서 연구생을 할지, 또는 창업을 할지로 형도 고민이었다.&lt;/p&gt;
&lt;p&gt;형이 올 해 들어갈 창업 동아리에서는 여러 개발도 하고 창업 활동도 한다기에 내가 GSM을 다니며 친구들과 프로젝트 했던 경험들을 말해 주기도 했다. 이렇게 서로 상담하듯이 이야기들을 하다보니 금방 공책 내용이 꽉찼다.&lt;/p&gt;
&lt;img src=&quot;https://user-images.githubusercontent.com/68007145/155519614-5fb9298b-4a3f-4f07-8d68-0c1bd1d6b43f.jpg&quot; width=&quot;500&quot;&gt;
&lt;p&gt;그 외에도 가장 크게 위안이 되었던 부분은 군대 문제다. 나는 취직을 하면 산업기능요원으로 근무해 군대 문제를 해결 할 수 있었지만 대학 진학 시 군대를 무조껀 가게 된다. 이에 형은 군대를 가게 되더라도 대학을 가는게 좋을 것 같다고 했다.&lt;/p&gt;
&lt;p&gt;일단 군대의 경우도 케이스에 따라 다르지만 요즘에는 폰도 사용 가능하고 또 운동부터 사회 활동까지 다양한 경험이 가능하기에 가는것도 괜찮으며 산업 기능 요원의 경우 거의 3년인데 중소기업에서 돈받으며 일하게 되면 더 성장하기가 힘들어 질 수도 있다고 했다. 이 덕에 내 진로 선택을 확고이 다질 수 있었다.&lt;/p&gt;
&lt;h2&gt;마무리&lt;/h2&gt;
&lt;p&gt;3달이 순식간에 지나갔다. 매주 만나는 데도 계속 이야기 하다 보니 찬우 형은 생각이 깊은 사람이었고, 나도 중학교때 진로 상담 한 이후로 이렇게 나 자신에 대해 솔직하게 털어놓은 적은 처음이었던 것 같았다.&lt;/p&gt;
&lt;p&gt;찬우 형은 현재 생산 라인 관리직으로 자동차와 반도체를 두고 고민중이다. 이제는 취직으로 진로를 확고히 정해서 남은 대학 2년을 관련 활동에 신경쓰기로 했다.&lt;/p&gt;
&lt;p&gt;나는 아쉽게도 대학 진학은 생각하고 있지 않다. 진학 리스트까지 뽑았어서 형은 조금 아쉬워 했다. 대학에서의 얻는 점이 공부보다는 참여 가능한 활동들과 사람들과의 교류이지만 이 점 들은 사회에서도 충분히 가능하고 대학에서 배우는 것들이 이론 위주라는 것이 아쉬었던게 원인인 것 같다.&lt;/p&gt;
&lt;p&gt;현재는 창업을 목표로 열심히 달려가고 있지만 대학 공부를 포기할 생각은 아니다. 학점 은행제도를 통해서 대학 강의를 수강할 생각이고 추후 상황에 따라서 대학 편입을 생각하고 있다.&lt;/p&gt;
&lt;p&gt;고등학교에서 있었던 일들중 가장 값지고 나에게는 가장 중요했던 경험이지 않았나 싶은 3달이었다. 나의 진로에 대해 누구보다 걱정해주고 공감해준 형에게 고맙고 형도 취직에 꼭 성공해서 나중에 술 한잔 사줬으면 좋겠다.&lt;/p&gt;
&lt;img src=&quot;https://user-images.githubusercontent.com/68007145/153209118-362034e1-2f12-4221-9fea-55b7f5861a18.jpg&quot; width=&quot;600&quot;&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;h3&gt;고인물은 언젠가 썩기 마련이야 그래서 우리는 계속 흘러야만해 -성찬우&lt;/h3&gt;
&lt;p&gt;Old water will rot someday, so we have to keep flowing&lt;/p&gt;
&lt;/blockquote&gt;</content:encoded></item><item><title><![CDATA[하버드와 구글에서 내가 배운 것(What I learned from Harvard and Google)]]></title><description><![CDATA[하버드와 구글에서 내가 배운 것(What I learned from Harvard and Google…]]></description><link>https://bosoek.github.io/harvard_and_google/</link><guid isPermaLink="false">https://bosoek.github.io/harvard_and_google/</guid><pubDate>Thu, 20 Jan 2022 10:00:00 GMT</pubDate><content:encoded>&lt;hr&gt;
&lt;h1&gt;하버드와 구글에서 내가 배운 것(What I learned from Harvard and Google)&lt;/h1&gt;
&lt;p&gt;일본의 고등학교를 재학중 진로에 대한 고민으로 자퇴후 미국으로 넘어가 칼리지 대학을 졸업하고 일본에서 창업을 한 후 또 다시 미국의 하버드로 입학을 한 특이한(?) 경력의 &lt;strong&gt;이시즈미 토모에&lt;/strong&gt; 님이 집필한 책이다.&lt;/p&gt;
&lt;p&gt;책에는 일본에서 공부하시던 토모에님이 미국으로 넘어가 하버드에서 배운점들, 그리고 구글에서 근무하며 얻은 마이드들과 관련 경험들을 적으셨다.&lt;/p&gt;
&lt;img src=&quot;https://user-images.githubusercontent.com/68007145/152284983-2d545284-08a0-46ce-8f41-d10097fed23d.jpg&quot; width=&quot;600&quot;&gt;  
&lt;p&gt;위 구절이 하버드 MBA의 사명인데, 단순히 회사의 예산에서 자신의 몫을 키우는 것만이 아닌 회사의 비즈니스를 키워 사회 전체의 파이를 키워야 한다고 말하는 구절이다.&lt;/p&gt;
&lt;p&gt;아마 일반적인 대학들은 각각의 회사의 이익을 키우는 것에 집중을 하며 그를 학습하는 대다수의 학생들도 개개인의 회사의 이익만을 집중한다. 물론 이런 점들이 나쁜 것은 아니지만 그 결과 뉴스에서 종종 접하는 사기 사건, 기업간의 갈등이 생기는 것이라고 책은 말한다.
그리고 이에 대해 하버드는 회사를 키움으로써 사회 전반을 키우는 것이 중요하다라고 말하는 관점의 변화가 신선했다.&lt;/p&gt;
&lt;img src=&quot;https://user-images.githubusercontent.com/68007145/152284990-581b72a5-4d00-4639-bdb2-4062859b5eca.jpg&quot; width=&quot;600&quot;&gt;  
&lt;p&gt;아마 대다수의 사람들은 경제적인 안정을 위한 승진, 급여 인상을 단순한 커리어의 목표로써 세운다. 그리고 나 또한 급여를 목표로써 취직을 준비 중이였고 생각 중이였다. 하지만 그에 대해 책은 승진을 목표로써 커리어를 키운다면 보는 시야가 줄어든다.&lt;/p&gt;
&lt;p&gt;때문에 내가 재밌는것, 나를 멀리 데려다 줄 수 있는 것을 분석하며 나아가라고 말한다.&lt;/p&gt;
&lt;p&gt;이처럼 이 책에서는 계속 단순한 이익만이 아닌 자기 자신의 가치를 키우고 발전시키는 것의 중요성을 언급한다. 끊임 없기 고민하고 분석하며, 자신만의 프라이드를 세우고 계속해서 성장해 나가는것, 그것이 본인의 삶의 방식이라고 설명하고 있다.&lt;/p&gt;
&lt;p&gt;이를 가르친 하버드와 구글, 그리고 그곳들에서 배출된 여러 사람들을 보면 나도 단순한 돈만을 쫓아 가는게 아닌 나만의 가치를 발전시키는 것에 대해 진지하게 생각해 봐야 할 시기라고 생각했다.&lt;/p&gt;
&lt;img src=&quot;https://user-images.githubusercontent.com/68007145/152284991-56a934da-cc81-4ea9-8fe2-4d84bf4fc735.jpg&quot; width=&quot;500&quot;&gt;
&lt;p&gt;개인적으로 많은 사람들에게 해당되는 이야기라는 생각이 들었다. 늘 지금 당장 해결할 수 있지도 않으면서 추상적인 미래의 일들을 미리 걱정하고 스트레스 받는 것보다는 당장 뭔가를 할 수 있는것도 아니고 적어도 지금은 닥친 일들을 해결해야하며 &lt;strong&gt;‘눈앞에 집중한다.’&lt;/strong&gt; 라는 말이 많은 사람들에게 꼭 필요한 말이었던것 같았다.&lt;/p&gt;
&lt;p&gt;책을 읽어보면 알 수 있지만 원래 일본에서는 보수적이고 경직된 사고방식을 가졌던 그녀가 미국의 하버드와 구글에서 얻은 가치관이나 마음가짐들, 신념들에 대해 읽다 보면 질 좋은 교육 환경과 의욕넘치는 주변 사람들이 학습 및 인생에 있어서 얼마나 중요한지 깨닫게 된다.&lt;/p&gt;
&lt;p&gt;현재 나도 대학 진학과 취업 중에서 고민 중이고 뭘 하고 싶은지, 뭘 원하는지 나도 잘 모르는 시기이고 아직은 하고 싶은 것이 너무 많지만 이제는 선택과 집중을 해야 할 시기이고 그 과정에서 필요한 나만의 우선순위를 선정하게 도와준 이 책이 고맙다.&lt;/p&gt;
&lt;p&gt;나처럼 진로 고민 중인 학생들, 현재 뭘 하고 싶은 건지 그리고 인간관계에서 너무 힘든 사람들에게 이 책을 추천하고 싶고, 늘 망설이기만 하는 분들이 토모에님처럼 다음 의자를 기다리기만 하는 것이 아닌 스스로 변화를 쟁취하는 삶을 살았으면 좋겠다.&lt;/p&gt;
&lt;img src=&quot;https://user-images.githubusercontent.com/68007145/152284993-cd3d4970-ac38-432c-a99c-19f543e41074.jpg&quot; width=&quot;600&quot;&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;h3&gt;인생에 있어 ‘절대로 확실함’이란 있을 수 없다.&lt;/h3&gt;
&lt;p&gt;There can be no ‘absolute certainty’ in life.&lt;/p&gt;
&lt;h3&gt;단지 ‘기회’가 있을 뿐이다.&lt;/h3&gt;
&lt;p&gt;There is only an ‘opportunity’.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;h3&gt;전부가 잘못되고 있을 리는 없다.&lt;/h3&gt;
&lt;p&gt;There is no way that everything is going wrong.&lt;/p&gt;
&lt;h3&gt;망가진 어떤 시계라도 하루에 두 번은 정확한 시간을 알리기 때문이다. -마크 트웨인(Mark Twain)&lt;/h3&gt;
&lt;p&gt;This is because any broken watch informs the exact time twice a day.&lt;/p&gt;
&lt;/blockquote&gt;</content:encoded></item><item><title><![CDATA[BMO]]></title><description><![CDATA[BMO 약 한달 가까이 진행한 BMO 프로젝트가 끝났다. 개인적으로 죽을만큼 힘들었어서 지난 한달 반을 기록해본다. 프로젝트를 시작한 계기는 GSM 페스티벌이었다. 우리 학교는 매년 GSM…]]></description><link>https://bosoek.github.io/BMO/</link><guid isPermaLink="false">https://bosoek.github.io/BMO/</guid><pubDate>Sun, 09 Jan 2022 10:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;BMO&lt;/h1&gt;
&lt;p&gt;약 한달 가까이 진행한 BMO 프로젝트가 끝났다. 개인적으로 죽을만큼 힘들었어서 지난 한달 반을 기록해본다.&lt;/p&gt;
&lt;p&gt;프로젝트를 시작한 계기는 GSM 페스티벌이었다. 우리 학교는 매년 GSM 페스티벌을 하는데, 간단히 애들끼리 팀짜서 프로젝트하고 전시하는 것이다. 여기서 다른 해와 다른 점은 우리는 2학년 말인 이 GSM 페스티벌이 마지막이라는 것과, 페스티벌 프로젝트는 학교에서 지원을 엄청 많이 해준다는 것이다.&lt;/p&gt;
&lt;p&gt;때문에 정말 마지막으로 내가 하고 싶은 프로젝트가 뭔지에 대해 고민하게 되었고, 오래전부터 만들어 보고 싶었던 BMO를 만들어보자!라고 생각하게 되어 시작한 프로젝트다.&lt;/p&gt;
&lt;img src=&quot;https://i1.sndcdn.com/artworks-9ZOsWrVFOXUkvPmN-P7M4SA-t500x500.jpg&quot; width=&quot;400&quot;&gt;
&lt;p&gt;참고로 비모는 “어드벤처 타임”이라는 만화에 나오는 인공지능 로봇이다. 해당 만화를 너무 좋아하기도 하고 비모가 귀엽기도 해서 예전부터 생각했던 프로젝트였고, 주 컨셉을 대화형 친구 로봇으로 잡고 친구들을 꼬셔 팀을 만들었다.&lt;/p&gt;
&lt;p&gt;그렇게 핵심 기능들과 필요한 재료등등을 적당히 산정했다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;비모의 갑바(몸체부분)&lt;/li&gt;
&lt;li&gt;비모 얼굴이 나올 디스플레이&lt;/li&gt;
&lt;li&gt;사용자 말을 인식할 마이크, 스피커&lt;/li&gt;
&lt;li&gt;팔이 돌아갈수 있도록 모터&lt;/li&gt;
&lt;li&gt;사용자 얼굴을 아이트래킹하기 위한 카메라&lt;/li&gt;
&lt;li&gt;대화형 AI&lt;/li&gt;
&lt;li&gt;STT, TTS 모델 구현&lt;/li&gt;
&lt;li&gt;비모 목소리 구현을 위한 데이터셋 구축&lt;/li&gt;
&lt;li&gt;내부 회로 납땝 및 조립&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;여기서 함정은 남은 기간이 약 30일 정도라는거다. 기간이 많다고 생각할 수도 있겠지만 그동안에 몸체 3D 모델링 및 프린팅(몸체 자체가 꽤 커서 - 50cm정도 - 뽑는데만 해도 꽤 시간이 걸린다), 부품은 재료 신청 후 올때까지 무작정 기다려야하고, 데이터셋은 있는지에 대한 유무도 모른다.&lt;/p&gt;
&lt;img src=&quot;https://mblogthumb-phinf.pstatic.net/MjAxODA1MTJfMTM2/MDAxNTI2MTMyMTQ3MjE0.tnsuVf2u_kZiodJhynHrcss3R_435px1UWhppvnZFMYg.CKMDaNOJT1p_SE-eLDmfRv1p_p5EeStgpVJROu4IP6Yg.PNG.crictor11/DV4pD0pVAAUVWFf.png?type=w800&quot; width=&quot;400&quot;&gt;
&lt;p&gt;이때 살짝 아차 싶었지만 이미 팀 소집도 다 완료되었고 이제는 아이디어를 바꾸는게 힘들어서 기간보고 개발중에 안되는건 버리고 챙길수 있는 것만 챙기면서 하자며 프로젝트를 시작하게되었다.&lt;/p&gt;
&lt;p&gt;그 후 바로 한달 기간에 대한 일정을 확실히 했다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1주일에 3D 모델링 완료, 부품 신청, 데이터셋 수집시작&lt;/li&gt;
&lt;li&gt;2주일에 회로 납땜 시작, 부품 도착, 데이터셋 계속 수집&lt;/li&gt;
&lt;li&gt;3주일에 부품 조립, 모델 파인튜닝&lt;/li&gt;
&lt;li&gt;4주일에 전시&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;일정 산출 후에는 역활 분담을 확실히 했다. 다행히 팀원중 한명이 3D 모델링을 할 줄 알아서 그 친구에게 비모의 외피 모델링을 맡겼고, 나는 기존에 만들어둔 채팅 모델이 있어서 대화 데이터셋을 구축해서 대화 ai를 만들고, 남은 팀원 두명에게 애니메이션의 비모 목소리 데이터를 수집해달라고 했다.&lt;/p&gt;
&lt;p&gt;개발 초기에는 생각보다 순탄했다. 단순히 대화만 하기에는 버튼들이 너무 많고 심심해 보이니 게임을 넣자고 해서 python으로 테트리스, 팩맨, 공룡 게임을 만들었고, 버튼을 누르면 랜덤 노래를 틀어주는 기능도 개발했다.&lt;/p&gt;
&lt;img src=&quot;https://user-images.githubusercontent.com/69895365/146292384-48b7809e-ad5b-4405-bdc1-bd7078714803.png&quot; width=&quot;500&quot;&gt;
&lt;p&gt;모델링도 꽤 빨리나와서 프린트가 금방끝났고, 아이트래킹 기능 개발과 비모 표정 디자인도 첫주에 대부분 끝낼 수 있었다.&lt;/p&gt;
&lt;p&gt;대화 AI쪽도 순조로웠다. 케글에서 어드벤처 타임 만화의 대화 데이터셋을 찾아서 해당 파일을 번역해 데이터셋 구축후 약간의 수정을 거쳐 내가 기존에 만들었던 모델에 파인튜닝을 했다. 초반에는 자기 이름이 핀과 제이크라는둥의 문제도 있었지만 노가다를 통해 해결했다.&lt;/p&gt;
&lt;p&gt;STT쪽도 시간상 라이브러리를 가져와 구현하는 것에는 성공했는데, 문제는 TTS였다. 애니메이션 자체에 비모의 등장 타임이 타 캐릭터 대비 많지가 았았고, 아득 바득 음성 대사를 따서 배경 음악 제거등의 작업을 다 했을때 구해지는 시간이 30분 정도였다. 후에 HBO에 올라온 특별편의 대사까지 포함시에 50분 정도…&lt;/p&gt;
&lt;p&gt;해당 데이터셋만으로 학습시에 역시나 기계음만 가득한 목소리가 나왔고, 추가적인 데이터 셋을 구하기 위해 여자 목소리를 편집해서 쓰기도 하고, 카툰네트워크측에 저작권 문제로 내려간 애니메이션을 줄 수 있는지 문의하고, 비모 애니메이션 성우에게 메일을 보내기도 했다.&lt;/p&gt;
&lt;img src=&quot;https://s3.us-west-2.amazonaws.com/secure.notion-static.com/398d2301-81ee-44fa-aebd-99843475a04e/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;amp;X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&amp;amp;X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20221206%2Fus-west-2%2Fs3%2Faws4_request&amp;amp;X-Amz-Date=20221206T013626Z&amp;amp;X-Amz-Expires=86400&amp;amp;X-Amz-Signature=034405b07846949201b4b51c899f3ef96a6f38ade3433ae53b3475ae96eef12c&amp;amp;X-Amz-SignedHeaders=host&amp;amp;response-content-disposition=filename%3D%22Untitled.png%22&amp;amp;x-id=GetObject&quot; width=&quot;400&quot;&gt;
&lt;p&gt;카툰과 성우측에게는 답변을 받을 수 없었지만 여자 목소리를 편집해 사용한 데이터셋이 그나마 효과가 있었고, 그 덕에 겨우 비모와 비슷한 목소리를 구현할 수 있었다.&lt;/p&gt;
&lt;p&gt;그와중에 다행인지 하드웨어는 크게 문제는 없었다.&lt;/p&gt;
&lt;img src=&quot;https://user-images.githubusercontent.com/68007145/205798120-5db63df0-5e76-476f-965c-634c23b0ff8d.jpeg&quot; width=&quot;400&quot;&gt;
&lt;blockquote&gt;
&lt;p&gt;3D 프린터 후 도색작업중&lt;/p&gt;
&lt;/blockquote&gt;
&lt;img src=&quot;https://user-images.githubusercontent.com/68007145/205799050-84229982-e69a-464c-a9b6-bfe59f4141a9.jpeg&quot; width=&quot;400&quot;&gt;
&lt;blockquote&gt;
&lt;p&gt;내부 회로 연결&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;이 외에도 모델 생성을 하며 학습 시간이 너무 오래 걸려 문제가 생기기도 했고(TTS 학습에만 4일.. ㄷㄷ), 소프트웨어 코드 병합 과정에서 모델 응답 속도가 느려 웹 벡엔드로 따로 빼서 돌리는 등의 별별일이 다 있었다.&lt;/p&gt;
&lt;p&gt;그렇게 한달 내내 밤샘 작업이 진행되었다. 지금 생각해보면 한달 안에 인공지능 모델 4개 이상 만든다는 거부터가 말이 안되는 계획이었다.(아이트래킹, 감정 분류, 대화 모델, TTS, STT)&lt;/p&gt;
&lt;p&gt;그리고 드디어 대망의 페스티벌날&lt;/p&gt;
&lt;img src=&quot;https://user-images.githubusercontent.com/68007145/205803730-70cdbed0-a1fd-45e1-9905-068935359054.jpg&quot; width=&quot;400&quot;&gt;
&lt;p&gt;아무래도 알고 있는 만화 캐릭터여서 그런지 학생들의 관심이 많았다. 간단한 게임과 음악 재생, 대화 등을 하며 조금 어눌했지만 우리가 원했던 대로 친구라는 컨셉을 느낄 수 있어서 다행이었다.&lt;/p&gt;
&lt;p&gt;덕분인지 정말 다행히도 페스티벌에서 동상을 수상할 수 있었고 그로 인해 대한민국 교육 박람회에서 작품 전시를 할 수 있는 기회를 얻었다.&lt;/p&gt;
&lt;img src=&quot;https://user-images.githubusercontent.com/68007145/205804636-0e6c696d-1903-487f-8d78-3262b535f18d.jpg&quot; width=&quot;400&quot;&gt;
&lt;h2&gt;마치며&lt;/h2&gt;
&lt;p&gt;개발 과정 중이 늘 좋지 만은 않았다. 신청한 부품이 늦게 오기도 하고 데이터 수 관련으로 팀원들과 대립이 생기기도 했다. 하지만 결국 팀원들이 나를 믿어줬고, 또 함께 밤샘 작업을 해줬기에 성공적으로 완성할 수 있지 않았나 싶다.&lt;/p&gt;
&lt;p&gt;과정은 고생뿐이었지만 끝난 지금 시점에서는 재밌었고 잊지 못할 것 같다.&lt;/p&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;h3&gt;성장한다는 것은 정말 혼란스러운 일인것 같아. -비모(BMO)&lt;/h3&gt;
&lt;p&gt;Growing up is really confusing&lt;/p&gt;
&lt;/blockquote&gt;</content:encoded></item><item><title><![CDATA[GAN으로 우주 사진 생성하기]]></title><description><![CDATA[GAN으로 우주 사진 생성하기 평소 우주에 관심이 많아 우주 관련 프로젝트를 할 거 없나 찾다가 GAN을 알게되어 GAN…]]></description><link>https://bosoek.github.io/space_image/</link><guid isPermaLink="false">https://bosoek.github.io/space_image/</guid><pubDate>Sat, 30 Oct 2021 10:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;GAN으로 우주 사진 생성하기&lt;/h1&gt;
&lt;p&gt;평소 우주에 관심이 많아 우주 관련 프로젝트를 할 거 없나 찾다가 GAN을 알게되어 GAN으로 우주 이미지를 만들어 보면 재밌을 것 같아서 시작하게 되었다. 처음 예상과는 달리 프로젝트가 너무 오래 걸렸고 결과물도 그렇게 만족스럽지는 않아서 추후 더 보완해야 할 것 가지만 일단은 지금까지의 상황을 기록해 둔다.&lt;/p&gt;
&lt;p&gt;프로젝트를 시작하기 전에 우선은 GAN에 대한 가벼운 공부를 진행했다. GAN도 종류가 너무 많지만 나는 단순한 이미지 생성이라 가장 기본적인 DGAN으로 하기로 했고 DGAN만 가볍게 공부했다.&lt;/p&gt;
&lt;h2&gt;우주 이미지 데이터&lt;/h2&gt;
&lt;p&gt;지옥의 시작이였다. 우선 우주 이미지들을 크롤링 하기로 했는데 여러 플랫폼을 찾다가 품질도 괜찮고 저작권 문제도 없는 &lt;strong&gt;Pixabay&lt;/strong&gt; 의 이미지들을 &lt;code class=&quot;language-text&quot;&gt;space&lt;/code&gt; 태그로 검색해 크롤링 했다.&lt;/p&gt;
&lt;img src=&quot;https://user-images.githubusercontent.com/68007145/155723638-df2ee3dc-ba89-4923-8f48-5f0a998a923a.PNG&quot; width=&quot;700&quot;&gt;
&lt;p&gt;약 20000개 정도의 데이터들이 받아졌는데 개중에 우주 이미지가 아닌것들, 우주 이미지이지만 너무 현실 적이지 않은 것들 등을 약 3주 가량 걸렀고 반대로 비현실 적이어도 우주 이미지스럽고 아름답다(?)고 느껴지는 것들만 뽑아 최종적으로 3600개 정도의 이미지들을 모을 수 있었다.&lt;/p&gt;
&lt;p&gt;데이터 과정에서 솔직히 현타가 많이 왔다. 물론 AI 제작 과정에서는 데이터가 많은 비율을 차지하지만 단순히 순수 우주 이미지를 모으는 데만 3주가 걸리고 게다가 모인 데이터 양도 너무 적었기 때문이다.(물론 시작한 이상 끝은 봐야 하기에 멈추지는 않는다!)&lt;/p&gt;
&lt;p&gt;그 후에는 이미지들을 1대1 비율로 resize 해서 데이터 준비를 마쳤다.&lt;/p&gt;
&lt;h2&gt;모델 학습&lt;/h2&gt;
&lt;p&gt;모델은 Pytorch DCGAN Tutorial(&lt;a href=&quot;https://pytorch.org/tutorials/beginner/dcgan_faces_tutorial.html&quot;&gt;DCGAN Tutorial&lt;/a&gt;)을 참고하여 제작하였고 최대한 많이 학습 시키려고 했지만 내 컴퓨터가 못버티고 혼자 죽어버리는(?) 경우들이 너무 생겨서 최종적으로 500 epochs를 학습 시켰다.&lt;/p&gt;
&lt;p&gt;그렇게 나온 최종 결과물&lt;/p&gt;
&lt;img src=&quot;https://user-images.githubusercontent.com/68007145/155725997-916969ac-ecc8-44eb-bd50-da01dc70e1d9.png&quot; width=&quot;700&quot;&gt;
&lt;h2&gt;마치며&lt;/h2&gt;
&lt;p&gt;쓰읍… 솔직히 결과물이 잘 나왔다고는 말 못한다. 괜찮게 나온 것들도 있지만 행성 같은 경우는 막 찌그러 지기도 했고 전체 적으로 우주 보다는 닥터 스트레인지 영화에 나왔던 도르마무의 세계(?)처럼 되었다.&lt;/p&gt;
&lt;p&gt;근데 모델을 욕할 수 없는게 원래 데이터에 우주 비행사가 있는 걸 봐서 아마도 데이터를 내가 제대로 거르지 못한게 원인인 것 같다.&lt;/p&gt;
&lt;p&gt;하지만 그렇다고 않좋기만 했던 건 아니다. 처음으로 GAN을 써보기도 했고 내가 작성한 코드와 데이터 셋을 캐글(&lt;a href=&quot;https://www.kaggle.com/kimbosoek/cosmos-images/code&quot;&gt;Cosmos Images&lt;/a&gt;) 에 올려서 동메달을 받기도 했다.&lt;/p&gt;
&lt;p&gt;솔직히 고생만 많이 한 것 같은데 끝나고 나니 재밌었던 것 같다. 다음에는 데이터도 더 모으고 모델도 조금 고쳐서 더 나은 결과를 만들어 보고 싶다.&lt;/p&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;h3&gt;지구는 우주에 떠 있는 창백한 푸른 점 하나. -칼 세이건(Carl Sagan)&lt;/h3&gt;
&lt;p&gt;Earth is a pale blue dot floating in space.&lt;/p&gt;
&lt;/blockquote&gt;</content:encoded></item><item><title><![CDATA[KLUE로 모델 평가하기 CREW]]></title><description><![CDATA[KLUE로 모델 평가하기 CREW 약 2달 이상 진행 했던 KLUE로 모델 평가하기 Crew활동이 끝났다. 여러 감정들이 들어 지난 2달 동안의 Crew…]]></description><link>https://bosoek.github.io/klue_baseline/</link><guid isPermaLink="false">https://bosoek.github.io/klue_baseline/</guid><pubDate>Wed, 15 Sep 2021 10:00:00 GMT</pubDate><content:encoded>&lt;hr&gt;
&lt;h1&gt;KLUE로 모델 평가하기 CREW&lt;/h1&gt;
&lt;p&gt;약 2달 이상 진행 했던 KLUE로 모델 평가하기 Crew활동이 끝났다. 여러 감정들이 들어 지난 2달 동안의 Crew 활동들을 남겨본다.&lt;/p&gt;
&lt;h2&gt;첫만남&lt;/h2&gt;
&lt;p&gt;평소에 혼자 공부했었는데 점점 지쳐가서 다른 사람들과 함께 공부할 커뮤니티를 찾던 도중 &lt;strong&gt;KLUE로 모델 평가하기 CREW&lt;/strong&gt; 를 찾게 되어 가입했다.&lt;/p&gt;
&lt;img src=&quot;https://user-images.githubusercontent.com/68007145/155735299-6a0d3ba4-863e-4948-bbd9-fd90cf6dad4a.PNG&quot; width=&quot;700&quot;&gt;
&lt;p&gt;본 crew는 Klue 벤치마크를 경험해보고 Klue Baseline을 제작해 공유하는 것이 목표였고 첫 밋업에서는 서로 자기소개를 하고 어떤 task를 담당할지를 정하며 분위기를 녹여 갔다.&lt;/p&gt;
&lt;p&gt;근데 여기서 함정은 나는 이때까지만 해도 HuggingFace도 몰랐을 정도로 초보자였었고 다른 크루원 분들의 대학생이거나 직장인 분들이였다.(고등학생은 나밖에 없었다)&lt;/p&gt;
&lt;h2&gt;크루 활동&lt;/h2&gt;
&lt;p&gt;본격적인 크루 활동이 시작되면서 많이 바빠졌다. 학교 생활 때문에 작업 시간이 부족하고 기숙사 들어가는 시간대에 크루 밋업 일정이 잡혀 있어서 시간도 촉박하고, 또 데이터 분석이나 Baseline을 구축해야 했는데 관련 경험이 없었기에 많이 해멨다.&lt;/p&gt;
&lt;p&gt;활동 중간에는 내가 크루 활동에 못 따라가는 것을 느끼며 내가 크루원들에게 피해를 주나? 내가 실력도 없이 괜한 시도를 하는 건가 싶기도 했다.&lt;/p&gt;
&lt;p&gt;그러다가 &lt;strong&gt;김대웅&lt;/strong&gt; 크루원님이 크루원들중 제일 빠르게 baseline을 제작해 공유해 주셨고, 관련해서 hugging Face 사용법과 다른 시각화 사이트들도 알려 주셨다.&lt;/p&gt;
&lt;p&gt;덕분에 기본적인 Baseline을 구축하고 개선 시키면서 논문, 블로그 발표등의 크루 활동들을 따라갈 수 있었다.&lt;/p&gt;
&lt;p&gt;또 일단 김대웅 크루원님이 스타트를 끊어 주시니 크루원이 빠르게 Baseline을 제작하며 크루 전체 활동에 속도가 붙을 수 있었다.&lt;/p&gt;
&lt;p&gt;마지막 밋업 때는 이태까지 작업했던 결과물들을 페이지로 제작해 인터넷에 공유 했고 약 9주간 함께 했던 크루원들과 소통하고 앞으로의 할일 등이나 진로들을 묻고 답하며 훈훈하게 마무리 됐다.&lt;/p&gt;
&lt;h2&gt;마치며&lt;/h2&gt;
&lt;p&gt;나의 첫 온라인 크루 활동이였고 또 크루를 통해 NLP 전반에 걸쳐 더 많이 공부할 수 있어서 너무 좋은 경험이였다. 특히 내가 만들 Baseline을 발표한 경험은 아마 잊지 못할 것이다.&lt;/p&gt;
&lt;p&gt;그리고 크루 활동 중간에 진도를 못나가 크루 활동에 참여력이 약간 떨어지고 원래 담당 task가 두개였는데 하나를 포기하는 문제가 있었음에도 나를 이끌어준 크루원 분들에게 너무나 감사했다.&lt;/p&gt;
&lt;p&gt;함께한 크루원 분들 모두 앞으로 좋은 일이 있길 바라고 나중에 다시 만날 수 있었으면 좋겠다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;크루 빌드 페이지 : &lt;a href=&quot;https://pseudo-lab.github.io/klue-baseline/docs/index.html&quot;&gt;바로가기&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;h3&gt;말은 쉽지, 코드를 보여줘. -리누스 토르발스(Linus Torvalds)&lt;/h3&gt;
&lt;p&gt;Talk is cheap. Show me the code.&lt;/p&gt;
&lt;/blockquote&gt;</content:encoded></item><item><title><![CDATA[Flask 개발 환경 구축하기]]></title><description><![CDATA[Flask 개발 환경 구축하기 파이썬 설치를 전제로 한다. 1. 가상 환경 생성하기 파이썬 가상환경은 파이썬 프로젝트시 독립된 환경을 만들어준다.(상황에 따라 가상환경에서 하나의 데스크톱에 다른 버전의 파이썬을 설치할 수 도 있다.) cmd…]]></description><link>https://bosoek.github.io/flask_Setting/</link><guid isPermaLink="false">https://bosoek.github.io/flask_Setting/</guid><pubDate>Mon, 13 Sep 2021 10:00:00 GMT</pubDate><content:encoded>&lt;hr&gt;
&lt;h1&gt;Flask 개발 환경 구축하기&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;파이썬 설치를 전제로 한다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;1. 가상 환경 생성하기&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;파이썬 가상환경은 파이썬 프로젝트시 독립된 환경을 만들어준다.(상황에 따라 가상환경에서 하나의 데스크톱에 다른 버전의 파이썬을 설치할 수 도 있다.)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;cmd에서 가상환경 디렉터리(통상 venvs)를 만든다.&lt;/li&gt;
&lt;li&gt;가상 환경을 만든다.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;D:\venvs&gt; python -m venv mysite&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;python -m venv&lt;/code&gt;는 파이썬 모듈중 venv를 이용하겠다는 의미이다.
&lt;code class=&quot;language-text&quot;&gt;mysite&lt;/code&gt;는 만들 가상환경 이름이다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;가상환경에 진입한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;생성한 mysite(가상환경)에 있는 Scripts 디렉터리의 &lt;code class=&quot;language-text&quot;&gt;activate&lt;/code&gt; 명령 을 수행하여 가상환경에 진입 가능.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;D:\venvs&gt; cd D:\venvs\mysite\Scripts
D:\venvs\mysite\Scripts&gt; activate
(가상환경명) D:\venvs\mysite\Scripts&gt;  # 가상환경 진입&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;가상환경에서 벗어닌다.&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;진입한 가상환경에서 벗어나려면 &lt;code class=&quot;language-text&quot;&gt;deactivate&lt;/code&gt; 을 사용한다&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;(가상환경명) C:\venvs\mysite\Scripts&gt; deactivate&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;flask 설치하기&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;플라스크는 가상환경 안에 설치한다&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;(가상환경명) D:\venvs\mysite\Scripts&gt; pip install flask&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;애플리케이션 만들기&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;from flask import Flask
app = Flask(__name__)

@app.route(&apos;/&apos;)
def hello_pybo():
    return &apos;Hello, Pybo!&apos;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;가장 기본적인 플라스크 서버 코드이다.&lt;br&gt;
&lt;code class=&quot;language-text&quot;&gt;app = Flask(__name__)&lt;/code&gt; : 플라스크 애플리케이션 실행 코드, 이때 __name__에는 해당 모듈 명(파일 이름)이 들어간다.&lt;br&gt;
&lt;code class=&quot;language-text&quot;&gt;@app.route&lt;/code&gt;는 특정 URL에 접속하면 바로 다음 줄에 있는 함수를 호출하는 플라스크의 데코레이터다.&lt;br&gt;
위 코드에서는 기본 url로 접속시 ‘Hello, Pybo!’ 라는 글이 출력된다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;기본 애플리케이션 설정하기&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;환경변수 FLASK APP에 애플리케이션을 지정한다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;(가상환경명) D:\venvs\mysite\Scripts&gt; set FLASK_APP=파일명&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;플라스크 서버 개발 환경으로 설정&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;플라스크 서버를 개발 모드로 연다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;(가상환경명) D:\venvs\mysite\Scripts&gt; set FLASK_ENV=development&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;플라스크 개발 환경 설치 &amp;#x26; 설정 완료!&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;h3&gt;테스트 될 수 없다면, 요구하지도 말라 -켄푸(KEN-POO)&lt;/h3&gt;
&lt;p&gt;If it can’t be tested, don’t ask for it&lt;/p&gt;
&lt;/blockquote&gt;</content:encoded></item><item><title><![CDATA[VSCode에서 Jupyter notebook 사용하기]]></title><description><![CDATA[VSCode에서 Jupyter notebook 사용하기 Machine Learning을 공부하는 사람들 이라면 대부분이 처음에 Jupyter Notebook(Lab)을 접할테지만 자동완성, 다크모드 등을 지원하는 코랩과는 다르게 원조인 Jupyter…]]></description><link>https://bosoek.github.io/vscode_jupyter/</link><guid isPermaLink="false">https://bosoek.github.io/vscode_jupyter/</guid><pubDate>Sun, 22 Aug 2021 10:00:00 GMT</pubDate><content:encoded>&lt;hr&gt;
&lt;h1&gt;VSCode에서 Jupyter notebook 사용하기&lt;/h1&gt;
&lt;p&gt;Machine Learning을 공부하는 사람들 이라면 대부분이 처음에 Jupyter Notebook(Lab)을 접할테지만 자동완성, 다크모드 등을 지원하는 코랩과는 다르게 원조인 Jupyter Notebook은 특유의 답답함으로 개발자 편의성이 중요해진 요즘에는 사용이 다소 꺼려집니다.&lt;/p&gt;
&lt;p&gt;하지만 모든 코드를 코랩에서만 할 수는 없기에 이번 시간에는 vscode로 편하게 Jupyter Notebook을 사용하는 방법을 포스팅 해 보도록 하겠습니다.😝&lt;/p&gt;
&lt;h3&gt;1. 우선 vscode에 들어가서 python과 jupyter Extentions을 설치합니다&lt;/h3&gt;
&lt;img src=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fme1xP%2FbtrcMGclmyB%2FkGpqTLFr9DSwdAnPauDy1k%2Fimg.png&quot; width=&quot;700&quot;&gt;
&lt;hr&gt;
&lt;h3&gt;2. 프로젝트의 가상 환경에서 jupyter를 설치 합니다&lt;/h3&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;python -m venv &amp;lt;가상환경 이름&gt;
&amp;lt;가상환경 이름&gt;\Scripts\activate
pip install jupyter&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;hr&gt;
&lt;h3&gt;3. 새로운 .ipynb 파일을 만들고 &lt;strong&gt;&amp;#x3C;커널 선택&gt;&lt;/strong&gt; 과 &amp;#x3C;Ctrl + Shift + P&gt; -&gt; &amp;#x3C;Select Interpreter&gt; 로 가상 환경을 선택하고 jupyter를 실행합니다.&lt;/h3&gt;
&lt;img src=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbCtuEh%2FbtrcMWFM8YV%2FkAvUidFRnBixZMK53SWvj1%2Fimg.png&quot; width=&quot;700&quot;&gt;
&lt;p&gt;이러면 끝~! 다들 즐거운 ML 코딩 하세요~😝&lt;/p&gt;
&lt;img src=&quot;https://user-images.githubusercontent.com/68007145/152316247-ec5c30b2-b506-4ed8-99db-db64e7b49053.png&quot; width=&quot;200&quot;&gt;
&lt;h3&gt;# Trouble Shooting&lt;/h3&gt;
&lt;p&gt;설치 과정에서 생기는 에러는 대부분 2개입니다. 각각의 해결법을 남겨놓겠습니다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Kernel died with exit code 1073741845…
&lt;ul&gt;
&lt;li&gt;사용자의 이름이 한글인지 확인하고 수정합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Kernel died with exit code 1…
&lt;ul&gt;
&lt;li&gt;python만 사용하시는 경우 python 재설치&lt;/li&gt;
&lt;li&gt;Anaconda 사용하시는 경우 &lt;code class=&quot;language-text&quot;&gt;conda install ipykernel --update-deps --force-reinstall&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;h3&gt;올바로 동작하지 않더라도 걱정말아라.&lt;/h3&gt;
&lt;p&gt;Don’t worry if it doesn’t work right.&lt;/p&gt;
&lt;h3&gt;모든 것이 그랬다면, 넌 직업을 잃었을테니까. -소프트웨어 공학에서의 모셔의 법칙(Mosher’s Law)&lt;/h3&gt;
&lt;p&gt;If everything did, you’d be out of a job.&lt;/p&gt;
&lt;/blockquote&gt;</content:encoded></item><item><title><![CDATA[Numpy 튜토리얼]]></title><description><![CDATA[Numpy 튜토리얼 넘파이는 벡터(1차원 배열), 행렬(2차원 배열) 등 수치 연산을 하는 선형 대수(Linear algebra) 라이브러리이다. 기초 개념 Numpy…]]></description><link>https://bosoek.github.io/Numpy/</link><guid isPermaLink="false">https://bosoek.github.io/Numpy/</guid><pubDate>Fri, 20 Aug 2021 10:00:00 GMT</pubDate><content:encoded>&lt;hr&gt;
&lt;h1&gt;Numpy 튜토리얼&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;넘파이는 벡터(1차원 배열), 행렬(2차원 배열) 등 수치 연산을 하는 선형 대수(Linear algebra) 라이브러리이다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;# 설치 코드
pip install numpy

# 패키지 추가
import numpy as np&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;hr&gt;
&lt;h2&gt;기초 개념&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Numpy에서는 모든 배열 값이 같은 타입이여야 하며, 각 차원을 축이라고 표현한다.
Numpy에서 배열은 &lt;code class=&quot;language-text&quot;&gt;ndarray&lt;/code&gt; 또는 &lt;code class=&quot;language-text&quot;&gt;array&lt;/code&gt;라고 하며 Python의 array와는 다르다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;스칼라(Scalar : 0D 텐서) : 0차원 축(행 &amp;amp; 차원) 즉, 숫자 한개
벡터(Vector : 1D 텐서) : 1차원 축(행 &amp;amp; 차원)
행렬(Matrix : 2D 텐서) : 2차원 축(행 &amp;amp; 차원)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h3&gt;&lt;code class=&quot;language-text&quot;&gt;numpy.ndarray&lt;/code&gt;의 대표 속성값&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;ndarray.shape&lt;/code&gt; : 배열의 각 축(axis)의 크기&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;ndarray.ndim&lt;/code&gt; : 축의 개수&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;ndarray.dtype&lt;/code&gt; : 각 요소의 타입&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;ndarray.itemsize&lt;/code&gt; : 각요소의 타입의 bytes 크기&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;ndarray.size&lt;/code&gt; : 전체 요소의 개수&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h3&gt;배열 생성&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;np.array()&lt;/code&gt;에 &lt;strong&gt;튜플이나 리스트&lt;/strong&gt; 를 입력하여 &lt;code class=&quot;language-text&quot;&gt;numpy.ndarray&lt;/code&gt;를 만들수 있다&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;dtype = complex&lt;/code&gt;로 복소수 값 생성 가능하다.
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;print(np.array([[1,2,], [3,4]], dtype = complex))
# [[1.+0.j 2.+0.j]
#  [3.+0.j 4.+0.j]]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;np.zeros(shape)&lt;/code&gt; : 0으로 구성된 N차원 배열 생성&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;np.ones(shape)&lt;/code&gt; : 1로 구성된 N차원 배열 생성&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;np.empty(shape)&lt;/code&gt; : 초기화되지 않은 N차원 배열 생성
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;print(np.zeros((3,4)))
# [[0. 0. 0. 0.]
#  [0. 0. 0. 0.]
#  [0. 0. 0. 0.]]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;np.arange(a, b, c)&lt;/code&gt; : a이상 b미만까지 c씩 차이나는 배열 생성&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;np.arange(a)&lt;/code&gt; : 0 ~ a 까지의 배열 생성&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;np.linspace(a, b, c)&lt;/code&gt; : a ~ b까지 c등분한 배열 생성&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h3&gt;배열 차원 변환&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;np.ndarray.reshape()&lt;/code&gt; : 데이터의 차원을 변경
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;# [10000] 배열을 [100, 100] 배열로 변경
print(np.arange(10000).reshape(100,100))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h3&gt;넘파이 연산(브로드캐스팅)&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;브로드캐스팅은 행렬(shape)이 다른 넘파이 배열끼리의 계산시 넘파이 내부에서 자동으로 행렬(Shape)을 맞춰주는 기능&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;np.array([1,2,3,4,5]) * 2 
# Broadcasting
np.array([1,2,3,4,5]) * np.array([2,2,2,2,2])&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;차원(ndim)이 같고 축(axis)의 값이 같거나 1이여야 연산 가능하며, 각 축의 값이 다르면 브로드캐스팅되어 값이 복사된다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;* &lt;/code&gt; : 각각의 원소끼리 곱셈&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;@ &lt;/code&gt; : 행렬 곱셈&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;.dot() &lt;/code&gt; : 행렬 내적&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;수치 계산시 타입이 다르면 타입이 큰쪽(int &amp;#x3C; float &amp;#x3C; complex)으로 자동 변경됨&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;.sum(np.ndarray)&lt;/code&gt; : 모든 요소의 합&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;.min(np.ndarray)&lt;/code&gt; : 모든 요소 중 최소값&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;.max(np.ndarray)&lt;/code&gt; : 모든 요소 중 최대값&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;.argmax(np.ndarray)&lt;/code&gt; : 모든 요소 중 최대값의 인덱스&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;.cumsum(np.ndarray)&lt;/code&gt; : 모든 요소의 누적합&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;.sum(), .min(), .max(), .cumsum() 등의 연산에 axis 값을 입력하면 축을 기준으로 연산 가능하다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;행렬 변경&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;np.ndarray.revel()&lt;/code&gt; : Shape을 1차원으로 변경&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;np.ndarray.reshape()&lt;/code&gt; : Shape을 지정한 차원으로 변경
&lt;blockquote&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;.reshpae()&lt;/code&gt;을 사용할 때 차원값에 -1을 입력하면 -1 부분은 자동으로 차원을 채워준다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;np.ndarray.T&lt;/code&gt; : Shapedml 행과 열의 수를 변환(4,3 이면 3,4로)&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;np.ndarray.resize()&lt;/code&gt; : .reshape()과 동일한 기능이지만 원본 데이터 자체를 변경시킨다.&lt;/li&gt;
&lt;li&gt;데이터 쌓기
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;np.vstack()&lt;/code&gt; : axis=0 기준으로 쌓음(세로로)&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;np.hstack()&lt;/code&gt; : axis=1 기준으로 쌓음(가로로)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;데이터 쪼개기
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;np.hsplit()&lt;/code&gt; : 숫자 1개가 들어갈 결우 x개로 등분, 리스트를 넣을 경우 azis=1 기준 인덱스로 데이터 분할함
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;print(a)
# [[4. 4. 1. 7. 7. 8. 8. 8. 4. 3. 5. 3.]
#  [9. 8. 7. 5. 6. 8. 9. 6. 9. 5. 4. 7.]]

# [2,12] =&gt; [2,4] 데이터 3개로 등분
print(np.hsplit(a, 3))
# [array([[4., 4., 1., 7.],
#        [9., 8., 7., 5.]]), array([[7., 8., 8., 8.],
#        [6., 8., 9., 6.]]), array([[4., 3., 5., 3.],
#        [9., 5., 4., 7.]])]

# [2,12] =&gt; [:, :3], [:, 3:4], [:, 4:]로 분할
print(np.hsplit(a, (3,4)))
# [array([[4., 4., 1.],
#        [9., 8., 7.]]), array([[7.],
#        [5.]]), array([[7., 8., 8., 8., 4., 3., 5., 3.],
#        [6., 8., 9., 6., 9., 5., 4., 7.]])]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;데이터 복사&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;변수에 np.array를 넣으면 복사가 되는게 아닌 같은 주소를 참조할 뿐이다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;a = b.view()&lt;/code&gt; : a와 b가 같은 주소값을 가르킨다(한 변수의 값을 바꾸면 다른 변수의 값도 바뀜)&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;a = b.copy()&lt;/code&gt; : a와 b가 같은 데이터를 가진다.(한 변수 값을 바꾸면 다른 변수 값 안바뀜)&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;h3&gt;기계 지능은 인류가 만들어야 할 마지막 발명품입니다. - 닉 보스 트롬(Nick Boss Tromm)&lt;/h3&gt;
&lt;p&gt;Mechanical intelligence is the last invention that mankind should make.&lt;/p&gt;
&lt;/blockquote&gt;</content:encoded></item><item><title><![CDATA[Django 개발 환경 구축하기]]></title><description><![CDATA[Django 개발 환경 구축하기 파이썬 설치를 전제로 한다. 1. 가상 환경 생성하기 파이썬 가상환경은 파이썬 프로젝트시 독립된 환경을 만들어준다.(상황에 따라 가상환경에서 하나의 데스크톱에 다른 버전의 파이썬을 설치할 수 도 있다.) cmd…]]></description><link>https://bosoek.github.io/Django_Setting/</link><guid isPermaLink="false">https://bosoek.github.io/Django_Setting/</guid><pubDate>Fri, 20 Aug 2021 10:00:00 GMT</pubDate><content:encoded>&lt;hr&gt;
&lt;h1&gt;Django 개발 환경 구축하기&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;파이썬 설치를 전제로 한다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;1. 가상 환경 생성하기&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;파이썬 가상환경은 파이썬 프로젝트시 독립된 환경을 만들어준다.(상황에 따라 가상환경에서 하나의 데스크톱에 다른 버전의 파이썬을 설치할 수 도 있다.)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;cmd에서 가상환경 디렉터리(통상 venvs)를 만든다.&lt;/li&gt;
&lt;li&gt;가상 환경을 만든다.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;D:\venvs&gt; python -m venv mysite&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;python -m venv&lt;/code&gt;는 파이썬 모듈중 venv를 이용하겠다는 의미이다.
&lt;code class=&quot;language-text&quot;&gt;mysite&lt;/code&gt;는 만들 가상환경 이름이다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;가상환경에 진입한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;생성한 mysite(가상환경)에 있는 Scripts 디렉터리의 &lt;code class=&quot;language-text&quot;&gt;activate&lt;/code&gt; 명령 을 수행하여 가상환경에 진입 가능.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;D:\venvs&gt; cd D:\venvs\mysite\Scripts
D:\venvs\mysite\Scripts&gt; activate
(가상환경명) D:\venvs\mysite\Scripts&gt;  # 가상환경 진입&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;가상환경에서 벗어닌다.&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;진입한 가상환경에서 벗어나려면 &lt;code class=&quot;language-text&quot;&gt;deactivate&lt;/code&gt; 을 사용한다&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;(가상환경명) C:\venvs\mysite\Scripts&gt; deactivate&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;장고 설치하기&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;장고는 가상환경안에서 설치한다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;(가상환경명) D:\venvs\mysite\Scripts&gt; pip install django==3.1.3
(가상환경명) D:\venvs\mysite\Scripts&gt; python -m pip install --upgrade pip&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;첫번째 pip는 장고 3.1.3 버전을 설치하라는 명령어.
두번재 pip는 장고를 최신 버전으로 설치하라는 명령어.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;프로젝트 생성&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;장고의 플로젝트란 하나의 웹사이트이며 하나의 프로젝트 안에는 여러 앱이 존재하고, 이러한 앱들이 모여 웹 사이트를 구성한다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;프로젝트 디렉터리 생성하기&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;장고는 프로젝트가 여러개가 될수 있으므로 프로젝트 &lt;strong&gt;루트 디렉터리 생성&lt;/strong&gt; 이 필수다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;D:\&gt;mkdir projects
D:\&gt;cd projects(루트 디렉터리 이름)
D:\projects&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;프로젝트 루트 디렉터리 안에서 가상 환경에 진입하기&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;D:\projects&gt;D:\venvs\mysite\Scripts\activate&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;장고 프로젝트 생성 &amp;#x26; 이동하기&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;(가상환경명) D:\projects&gt;mkdir mysite(장고 프로젝트를 담을 디렉터리)
(가상환경명) D:\projects&gt;cd mysite
(가상환경명) D:\projects\mysite&gt;
(가상환경명) D:\projects\mysite&gt;django-admin startproject config .&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;장고 프로젝트는 가상 환경에서 django-admin으로 생성 가능하다.
이때 config 뒤의 점에 주의해야하며 점 기호는 현재 디렉터리를 프로젝트 디렉터리로 만들라는 의미이다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;개발 서버 구동 &amp;#x26; 종료하기&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;python manage.py runserver&lt;/code&gt; 명령으로 개발 서버가 구동되며 &lt;code class=&quot;language-text&quot;&gt;Ctrl+C&lt;/code&gt;를 누르면 개발 서버가 종료된다.
개발 서버는 &lt;code class=&quot;language-text&quot;&gt;127.0.0.1:8000&lt;/code&gt; 또는 &lt;code class=&quot;language-text&quot;&gt;localhost:8000&lt;/code&gt;에서 장고의 기본 웹사이트를 볼수 있다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Path 환경변수를 통한 가상 환경 진입 -&gt; 방법을 못찾음(추후에 커밋함)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;장고(파이썬) 개발 에디터 파이참 설치하기.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;파이참은 &lt;a href=&quot;http://www.jetbrains.com/ko-kr/pycharm/download/#section=windows&quot;&gt;www.jetbrains.com/ko-kr/pycharm/download/#section=windows&lt;/a&gt; 에서 설치 가능하며 &lt;Next&gt;만 선택하면 된다.
파이참 실행 후 &lt;Open&gt;으로 앞에서 생성한 장고 프로젝트를 연다.(예 : D:\projects\mysite)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;파이참 인터프리터 설정&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;파이참 메뉴에서 &lt;code class=&quot;language-text&quot;&gt;[File -&gt; Setting] -&gt; [Project: mysite -&gt; project Interpreter] -&gt; [Python Interpreter]&lt;/code&gt;의 톱니바퀴 모양에서 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;Add&gt; -&gt; &amp;lt;Existing enviroment&gt; -&gt; [Interpreter]&lt;/code&gt;오른쪽의 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;...&gt; -&gt; D:\venvs\mysite\Scripts\python.exe&lt;/code&gt; 선택
파이참에서 setting.py 파일의 &lt;code class=&quot;language-text&quot;&gt;[LANGUAGE_CODE]&lt;/code&gt;와 &lt;code class=&quot;language-text&quot;&gt;[TIME_ZONE]&lt;/code&gt;설정값을 수정한다.(언어와 시간을 한국으로 설정)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;LANGUAGE_CODE = &apos;ko-kr&apos;
TIME_ZONE = &apos;Asia/Seoul&apos;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;서버 구동시 언어가 한국어로 바뀌어 있다!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;장고 개발 환경 설치 &amp;#x26; 설정 완료!&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;h3&gt;품질이란 누가 보지 않을 때에도 제대로 돌아가는 걸 뜻한다. - 헨리 포드&lt;/h3&gt;
&lt;p&gt;Quality means that it works properly when no one looks at it.&lt;/p&gt;
&lt;/blockquote&gt;</content:encoded></item><item><title><![CDATA[Matplotlib Tutorial]]></title><description><![CDATA[Matplotlib Tutorial 은 파이썬 기반 그래프(플롯) 시각화 라이브러리이다.
 모듈의 각각의 함수로 그래프를 만들고 변화를 줄수 있다. 기본 그래프 pyplot.show() 그렸던 그래프들 출력하는 함수 pyplot.plot…]]></description><link>https://bosoek.github.io/matplotlib/</link><guid isPermaLink="false">https://bosoek.github.io/matplotlib/</guid><pubDate>Tue, 20 Jul 2021 10:00:00 GMT</pubDate><content:encoded>&lt;hr&gt;
&lt;h1&gt;Matplotlib Tutorial&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;Matplotlib&lt;/code&gt;은 파이썬 기반 그래프(플롯) 시각화 라이브러리이다.
&lt;code class=&quot;language-text&quot;&gt;matplotlib.pyplot&lt;/code&gt; 모듈의 각각의 함수로 그래프를 만들고 변화를 줄수 있다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;# 설치 코드
pip search matplotlib
pip install matplotlib
pip install --upgrade matplotlib

# 패키지 추가
import matplotlib.pyplot as plt
%matplotlib inline # jupyter에서 Shift+Enter를 치지 않고 Run으로 실행하여 그래프를 그릴 수 있음.&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;hr&gt;
&lt;h2&gt;기본 그래프&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h3&gt;pyplot.show()&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;그렸던 그래프들 출력하는 함수&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h3&gt;pyplot.plot()&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;선 또는 마커 그래프 그리기에 사용되는 함수로 리스트를 인수로 받는다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;y 값 : &lt;code class=&quot;language-text&quot;&gt;[1, 2, 3, 4]&lt;/code&gt;처럼 리스트가 한개인 경우 y값이라고 가정후 x값을 0부터 1씩 커지게 자동으로 만들어 낸다.&lt;/li&gt;
&lt;li&gt;x, y 값 : &lt;code class=&quot;language-text&quot;&gt;[1, 2, 3, 4,], [2,4,6,8]&lt;/code&gt;처럼 리스트가 두개면 각각 x, y로 그래프로 나타내준다.&lt;/li&gt;
&lt;li&gt;두개의 그래프 : 두개 이상의 리스트들은 새로운 그래프로 그려진다.(한 그래프에 여러 곡선들 제작 가능)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/68007145/118938613-cf080700-b989-11eb-9281-3afe2c769293.png&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;plot() 함수에 매개변수에 ‘bo’(파란 원형마커) 형식으로 색과 마커 방식을 지정할 수 있다&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;Color&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;b&lt;/code&gt;처럼 일반 지정도 되고 &lt;code class=&quot;language-text&quot;&gt;color=&apos;green&apos;&lt;/code&gt; 처럼 키워드로 지정해도 된다. 단, 키워드 지정에서는 css 색상과 Hex code도 사용할 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;b&lt;/code&gt; : blue&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;g&lt;/code&gt; : green&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;r&lt;/code&gt; : red&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;c&lt;/code&gt; : cyan&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;m&lt;/code&gt; : magenta&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;y&lt;/code&gt; : yellow&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;k&lt;/code&gt; : black&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;w&lt;/code&gt; : white&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Line Styles&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;-&lt;/code&gt;처럼 일반 지정도 되고 &lt;code class=&quot;language-text&quot;&gt;linestyle=&apos;-&apos;&lt;/code&gt;처럼 키워드로 지정해도 된다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;-&lt;/code&gt; : 실선 스타일&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;--&lt;/code&gt; : 파선 스타일&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;-.&lt;/code&gt; : 점-선 스타일&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;:&lt;/code&gt; : 점선 스타일&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Markers&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;o&lt;/code&gt;처럼 일반 지정도 되고 &lt;code class=&quot;language-text&quot;&gt;marker=&apos;o&apos;&lt;/code&gt;처럼 키워드로 지정해도 된다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;.&lt;/code&gt; : 포인트&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;,&lt;/code&gt; : 픽셀&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;o&lt;/code&gt; : 원형&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;v&lt;/code&gt; : 아래쪽 삼각형&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;^&lt;/code&gt; : 위쪽 삼각형&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;&lt;/code&gt; : 왼쪽 삼각형&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;&gt;&lt;/code&gt; : 오른쪽 삼각형&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;1&lt;/code&gt; : 아래쪽 삼각별&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;2&lt;/code&gt; : 위쪽 삼각별&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;3&lt;/code&gt; : 왼쪽 삼각별&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;4&lt;/code&gt; : 오른쪽 삼각별&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;s&lt;/code&gt; : 사각형&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;p&lt;/code&gt; : 오각형&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;*&lt;/code&gt; : 별&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;h&lt;/code&gt; : 육각형 1&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;H&lt;/code&gt; : 육각형 2&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;+&lt;/code&gt; : + 마크&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;x&lt;/code&gt; : x 마크&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;D&lt;/code&gt; : 다이아몬드&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;d&lt;/code&gt; : 앏은 다이아몬드&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;|&lt;/code&gt; : | 마크&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;_&lt;/code&gt; : _ 마크&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h3&gt;title()&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;그래프의 제목 지정(타이틀을 여러개 지정할 수도 있다)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;매개변수로 타이틀 글을 준다&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;loc = &apos;right/left/center&apos;&lt;/code&gt; : 타이틀을 오른쪽(right) 위, 왼쪽(left) 위, 가운데(center) 위에 나타나게 한다&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;pad&lt;/code&gt; : 타이틀과 그래프와의 관계를 설정한다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;fontdict&lt;/code&gt; : fontsize(포인트 단위 숫자나 &lt;code class=&quot;language-text&quot;&gt;smaller&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;x-large&lt;/code&gt; 등의 상대적인 설정)와 fontweight(&lt;code class=&quot;language-text&quot;&gt;normal&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;bold&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;heavy&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;light&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;ultrabold&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;ultralight&lt;/code&gt; 설정 가능)를 딕셔너리 형태로 받는다&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;# 예제 코드
plt.title(&apos;Sample graph&apos;, loc=&apos;right&apos;, pad=20)
title_font = {
    &apos;fontsize&apos;: 16,
    &apos;fontweight&apos;: &apos;bold&apos;
}
plt.title(&apos;Sample graph&apos;, fontdict=title_font, loc=&apos;left&apos;, pad=20)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/68007145/118962326-38931000-b9a0-11eb-8e74-8f567e551327.png&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;축 레이블 및 범위 설정&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h3&gt;xlabel()&lt;/h3&gt;
그래프에서 x축에 대한 레이블 표시(표시할 레이블을 인수로 받는다)&lt;/li&gt;
&lt;li&gt;
&lt;h3&gt;ylabel()&lt;/h3&gt;
그래프에서 y축에 대한 레이블 표시(표시할 레이블을 인수로 받는다)&lt;/li&gt;
&lt;li&gt;
&lt;h3&gt;axis()&lt;/h3&gt;
x, y축이 표시되는 범위를 지정(매개변수 : &lt;code class=&quot;language-text&quot;&gt;xmin&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;xmax&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;ymin&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;ymax&lt;/code&gt;)
&lt;strong&gt;입력값이 없으면 데이터에 맞게 자동으로 범위를 지정함&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;그래프 영역 채우기&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h3&gt;fill_between()&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;X-Label 그래프의 특정 영역을 채워서 강조&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;X 배열 : X 레이블의 어떤 지점을 그릴것인지 지정&lt;/li&gt;
&lt;li&gt;Y 배열 : Y 레이블의 어떤 지점까지 그릴것인지 지정&lt;/li&gt;
&lt;li&gt;color : 색 지정&lt;/li&gt;
&lt;li&gt;alpha : 투명도(1이 최대)&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;# 예제 코드
x = [1, 2, 3, 4]
y = [1, 4, 9, 16]
plt.plot(x, y)
plt.fill_between(x[1:3], y[1:3], alpha=0.5)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;(x[1], y[1]), (x[2], y[2]), (x[1], 0), (x[2], 0)을 잇는 영역이 채워진다&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/68007145/118950473-311a3980-b995-11eb-878f-5624431058c8.png&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h3&gt;fill_betweenx()&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;X-Label 그래프의 특정 영역을 채워서 강조&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Y 배열 : Y 레이블의 어떤 지점까지 그릴것인지 지정&lt;/li&gt;
&lt;li&gt;X 배열 : X 레이블의 어떤 지점을 그릴것인지 지정&lt;/li&gt;
&lt;li&gt;color : 색 지정&lt;/li&gt;
&lt;li&gt;alpha : 투명도(1이 최대)&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;# 예제 코드
plt.plot(x, y)
plt.fill_between(y[2:4]), x[2:4], alpha=0.5)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;(x[2], y[2]), (x[3], y[3]), (0, y[2]), (0, y[3])을 잇는 영역이 채워진다&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/68007145/118950897-94a46700-b995-11eb-9dff-180f293b77b1.png&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h3&gt;두 그래프 사이 영역 채우기&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;두 그래프 사이를 채워서 강조&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;영역을 채울 X값 지정&lt;/li&gt;
&lt;li&gt;영역을 채울 두 그래프의 Y값 지정&lt;/li&gt;
&lt;li&gt;나머지는 동일&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;# 예제 코드
x = [1, 2, 3, 4]
y1 = [1, 4, 9, 16]
y2 = [1, 2, 4, 8]

plt.fill_between(x[1:3], y1[1:3], y2[1:3])
# fill_betweenx도 가능&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;(x[1], y[1]), (x[1], y[2]), (x[2], y[1]), (x[2], y[2]) 사이 영역을 채운다&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/68007145/118951549-23b17f00-b996-11eb-8e27-423992274f43.png&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h3&gt;fill()&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;임의의 영역을 채워서 강조&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;영역을 그릴 4가지 지점의 X, Y좌표 지정&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;# 예제 코드
plt.fill([1.9, 1.9, 3.1, 3.1], [2, 5, 11, 8])&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/68007145/118951957-7db24480-b996-11eb-8499-76ec25abc172.png&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;그리드 및 눈금 표시하기&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h3&gt;grid()&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;그래프에 격자 표시&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;True&lt;/code&gt; : True로 설정시 그리드 표시됨(X, Y). default는 False.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;axis&lt;/code&gt; = ‘both/x/y’ : 그리드 방향 지정. default는 both&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;color&lt;/code&gt; : 색 지정&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;alpha&lt;/code&gt; : 투명도&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;linestyle&lt;/code&gt; : 선 스타일&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;which&lt;/code&gt; = ‘major/minor/both’ : 주눈금, 보조눈금 표시&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h3&gt;xticks()&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;X축에 틱(그래프의 축에 간격을 구분하는 표시 눈금)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;리스트나 넘파이 배열을 입력시 해당 위치에 눈금 &amp;#x26; 숫자 레이블 표시&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;labels = [&apos;1번&apos;, &apos;2번&apos; ...]&lt;/code&gt; : 눈금 레이블을 명시적으로 지정 가능&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;lebels 파라미터 대신 튜블로 지정해도 가능&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h3&gt;yticks()&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Y축에 틱(그래프의 축에 간격을 구분하는 표시 눈금)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;리스트나 넘파이 배열을 입력시 해당 위치에 눈금 &amp;#x26; 숫자 레이블 표시&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;labels = [&apos;1번&apos;, &apos;2번&apos; ...]&lt;/code&gt; : 눈금 레이블을 명시적으로 지정 가능&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;lebels 파라미터 대신 튜블로 지정해도 가능&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h3&gt;tick_params()&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;눈금 스타일 지정&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;axis&lt;/code&gt; : 설정 적용 축 지정(X, Y, both)&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;direction&lt;/code&gt; : 눈금 안/밖 표시 지정(in:안, out:밖, inout:둘다)&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;length&lt;/code&gt; : 눈금이 길이&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;pad&lt;/code&gt; : 눈금과 레이블과의 거리&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;labelsize&lt;/code&gt; : 레이블의 크기 지정&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;labelcolor&lt;/code&gt; : 레이블의 색상 지정&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;top&lt;/code&gt; = True : 눈금이 위에 표시됨(default:False)&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;bottom&lt;/code&gt; = True : 눈금이 아래에 표시됨(default:False)&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;left&lt;/code&gt; = True : 눈금이 왼쪽에 표시됨(default:False)&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;right&lt;/code&gt; = True : 눈금이 오른쪽에 표시됨(default:False)&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;width&lt;/code&gt; : 눈금의 너비 지정&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;color&lt;/code&gt; : 눈금의 색상 지정&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;수직선/수평선 표시&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h3&gt;axhline()&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;그래프 특정 y(가로)값에 수평선 표시&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;첫번째 인자 : y값으로서 수평선의 위치&lt;/li&gt;
&lt;li&gt;두번째 인자 : xmin -&gt; 0(왼쪽 끝)에서 1(오른쪽 끝)사이의 값을 넣는다&lt;/li&gt;
&lt;li&gt;세번째 인자 : xmax -&gt; 0(왼쪽 끝)에서 1(오른쪽 끝)사이의 값을 넣는다&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;xmin과 xmax에 선이 생기는 것&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;color&lt;/code&gt; : 색&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;linestyle&lt;/code&gt; : 선 스타일&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;linewidth&lt;/code&gt; = 선 두께(수 지정)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h3&gt;axvline()&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;그래프 특정 x(세로)값에 수직선 표시&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;첫번째 인자 : x값으로서 수평선의 위치&lt;/li&gt;
&lt;li&gt;두번째 인자 : xmin -&gt; 0(아래쪽 끝)에서 1(위쪽 끝)사이의 값을 넣는다&lt;/li&gt;
&lt;li&gt;세번째 인자 : xmax -&gt; 0(아래쪽 끝)에서 1(위쪽 끝)사이의 값을 넣는다&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;xmin과 xmax에 선이 생기는 것&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;color&lt;/code&gt; : 색&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;linestyle&lt;/code&gt; : 선 스타일&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;linewidth&lt;/code&gt; = 선 두께(수 지정)&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;# 예제 코드
a = np.arange(0, 2, 0.2)
plt.plot(a, a, &apos;bo&apos;)
plt.plot(a, a**2, color=&apos;#e35f62&apos;, marker=&apos;*&apos;, linewidth=2)
plt.plot(a, a**3, color=&apos;springgreen&apos;, marker=&apos;^&apos;, markersize=9)
plt.xticks(np.arange(0, 2, 0.2), labels=[&apos;Jan&apos;, &apos;&apos;, &apos;Feb&apos;, &apos;&apos;, &apos;Mar&apos;, &apos;&apos;, &apos;May&apos;, &apos;&apos;, &apos;June&apos;, &apos;&apos;, &apos;July&apos;])
plt.yticks(np.arange(0, 7), (&apos;0&apos;, &apos;1GB&apos;, &apos;2GB&apos;, &apos;3GB&apos;, &apos;4GB&apos;, &apos;5GB&apos;, &apos;6GB&apos;))
plt.axhline(1, 0, 0.55, color=&apos;gray&apos;, linestyle=&apos;--&apos;, linewidth=&apos;1&apos;)
plt.axvline(1, 0, 0.16, color=&apos;lightgray&apos;, linestyle=&apos;:&apos;, linewidth=&apos;2&apos;)
plt.axhline(5.83, 0, 0.95, color=&apos;gray&apos;, linestyle=&apos;--&apos;, linewidth=&apos;1&apos;)
plt.axvline(1.8, 0, 0.95, color=&apos;lightgray&apos;, linestyle=&apos;:&apos;, linewidth=&apos;2&apos;)
plt.show()&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/68007145/118963728-b4da2300-b9a1-11eb-9a9a-64e30d2f73c9.png&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h3&gt;hlines()&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Y를 따라 수평선 표시&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;첫번째 인자 : Y 좌표&lt;/li&gt;
&lt;li&gt;두번째 인자 : xmin -&gt; 수평선 시작 지점&lt;/li&gt;
&lt;li&gt;세번째 인자 : xmax -&gt; 수평선 끝나는 지점&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;점(xmin, y)에서 점(xmax, y)를 따라 수평선 표시&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;color&lt;/code&gt; : 색&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;linewidth&lt;/code&gt; : 선두께&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h3&gt;vlines()&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;X를 따라 수평선 표시&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;첫번째 인자 : X 좌표&lt;/li&gt;
&lt;li&gt;두번째 인자 : ymin -&gt; 수평선 시작 지점&lt;/li&gt;
&lt;li&gt;세번째 인자 : ymax -&gt; 수평선 끝나는 지점&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;점(x, ymin)에서 점(x, ymax)를 따라 수평선 표시&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;color&lt;/code&gt; : 색&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;linewidth&lt;/code&gt; : 선두께&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;# 예제 코드
plt.hlines(4, 1, 1.6, colors=&apos;pink&apos;, linewidth=3)
plt.vlines(1, 1, 4, colors=&apos;pink&apos;, linewidth=3) &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/68007145/118964444-785af700-b9a2-11eb-9238-095c84cbb879.png&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;막대 그래프 그리기&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h3&gt;bar()&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;그래프 개수와 값을 리스트 형태로 받아 막대 그래프로 출력&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;첫번째 인자 : 넘파이 배열로 막대 그래프 개수 지정(총 3개면 [0, 1, 2])&lt;/li&gt;
&lt;li&gt;두번째 인자 : 넘파이 배열에 해당하는 리스트 입력&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;width&lt;/code&gt; : 막대의 너비(default : 0.8)&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;align&lt;/code&gt; : 틱과 막대의 위치 조절(default : center, edge로 설정시 막대 왼쪽에 틱이 표시됨)&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;color&lt;/code&gt; : 막대의 색&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;edgecolor&lt;/code&gt; : 막대의 테두리 색을 지정(css타입 가능)&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;linewidth&lt;/code&gt; : 테두리 두께 지정&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;tick_label&lt;/code&gt; : 리스트 형태로 지정시 틱에 리스트 문자열을 순서대로 나타낼 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;log = True&lt;/code&gt; : Y축 로그 스케일로 표시&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;# 예제 코드
x = np.arange(3)
years = [&apos;2017&apos;, &apos;2018&apos;, &apos;2019&apos;]
values = [100, 400, 900]
plt.bar(x, values, width=0.6, align=&apos;edge&apos;, color=&quot;springgreen&quot;,
        edgecolor=&quot;gray&quot;, linewidth=3, tick_label=years, log=True)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;img src=&quot;https://user-images.githubusercontent.com/68007145/118965609-d3d9b480-b9a3-11eb-96e2-63372e5a3fe6.png&quot; alt=&quot;image&quot;&gt;&lt;/li&gt;
&lt;li&gt;
&lt;h3&gt;barh()&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;수평 막대 그래프 출력&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;첫번째 인자 : 넘파이 배열로 막대 그래프 개수 지정(총 3개면 [0, 1, 2])&lt;/li&gt;
&lt;li&gt;두번째 인자 : 넘파이 배열에 해당하는 리스트 입력&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;height&lt;/code&gt; : 막대의 높이(default : 0.8)&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;align&lt;/code&gt; : 틱과 막대의 위치 조절(default : center, edge로 설정시 막대 아래쪽에 틱이 표시됨)&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;color&lt;/code&gt; : 막대의 색&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;edgecolor&lt;/code&gt; : 막대의 테두리 색을 지정(css타입 가능)&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;linewidth&lt;/code&gt; : 테두리 두께 지정&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;tick_label&lt;/code&gt; : 리스트 형태로 지정시 틱에 리스트 문자열을 순서대로 나타낼 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;log&lt;/code&gt; = True : X축 로그 스케일로 표시&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;# 예제 코드
y = np.arange(3)
years = [&apos;2017&apos;, &apos;2018&apos;, &apos;2019&apos;]
values = [100, 400, 900]

plt.barh(y, values, height=-0.6, align=&apos;edge&apos;, color=&quot;springgreen&quot;,
        edgecolor=&quot;gray&quot;, linewidth=3, tick_label=years, log=False)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;img src=&quot;https://user-images.githubusercontent.com/68007145/118965906-22874e80-b9a4-11eb-90da-b8a8445b0095.png&quot; alt=&quot;image&quot;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;산점도 그리기&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;산점도&lt;/strong&gt; 는 두 변수 상관 관계를 직교 좌표계의 평면에 데이터를 점으로 표현하는 그래프&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h3&gt;scatter()&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;산점도 출력&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;2차원 산점도 그리기&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;X : X위치&lt;/li&gt;
&lt;li&gt;Y : Y위치&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;s = &apos;크기&apos;&lt;/code&gt; : 마커의 면적&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;c = &apos;색&apos;&lt;/code&gt; : 마커의 색깔&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;alpha = 값&lt;/code&gt; : 투명도&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;각각의 인자들은 리스트 형태로 여러개 지정하여 한번에 여러개의 마커들을 만들 수도 있다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;3차원 산점도 그리기&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;3차원 그래프를 위해서는 &lt;code class=&quot;language-text&quot;&gt;from mpl_toolkits.mplot3d import Axes3D&lt;/code&gt; 추가(맷플로팁 3.1 이상부터는 자동으로 포함되있음)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;rcParams로 figure의 사이즈 설정(figure란 그래프가 들어있는 객체)&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;plt.rcParams[&quot;figure.figsize&quot;] = (6, 6)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;3D axes를 위해 add_subplot()에 3D를 입력해준다&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;ax = fig.add_subplot(111, projection=&apos;3d&apos;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;매개인자들&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;X&lt;/code&gt; : X좌표&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Y&lt;/code&gt; : Y좌표&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Z&lt;/code&gt; : Z좌표&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;c =&apos;색&apos;&lt;/code&gt; : 색깔&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;marker=&apos;마크&apos;&lt;/code&gt; : 마크 형태&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;s=값&lt;/code&gt; : 크기&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;cmap = &apos;색&apos;&lt;/code&gt; : 맵 색깔&lt;/li&gt;
&lt;/ul&gt;
&lt;img src=&quot;https://user-images.githubusercontent.com/68007145/118970084-cbd04380-b9a8-11eb-860f-68bfe6dc4a49.png&quot; alt=&quot;image&quot;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;히스토그램 그리기&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;히스토그램&lt;/strong&gt; 은 도수분포표를 그래프로 나타낸 것으로, 가로는 계급, 세로는 도수를 나타낸다&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h3&gt;hist()&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;첫번째 인자 : 리스트 형태로 값 입력&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;bins = 값&lt;/code&gt; : 몇 개의 영역으로 쪼갤지 설정&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;density = True&lt;/code&gt; : 밀도 함수가 되어 막대 아래 면적이 1이된다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;alpha&lt;/code&gt; : 투명도&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;histtype = &apos;step/stepfilled&apos;&lt;/code&gt; : step은 막대 내부가 비어있고, stepfiled는 막대 내부가 채워진다.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;# 예제 코드
a = 2.0 * np.random.randn(10000) + 1.0
b = np.random.standard_normal(10000)
c = 20.0 * np.random.rand(5000) - 10.0

plt.hist(a, bins=100, density=True, alpha=0.7, histtype=&apos;step&apos;)
plt.hist(b, bins=50, density=True, alpha=0.5, histtype=&apos;stepfilled&apos;)
plt.hist(c, bins=100, density=True, alpha=0.9, histtype=&apos;step&apos;)
plt.show()&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;img src=&quot;https://user-images.githubusercontent.com/68007145/118970655-6d579500-b9a9-11eb-8a5a-84ed525977b0.png&quot; alt=&quot;image&quot;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;오차막대 그리기&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;데이터의 편차를 표시하기 위한 그래프 형태&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h3&gt;errorbar()&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;에러바 그래프를 그릴 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;x&lt;/code&gt; : X값&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;y&lt;/code&gt; : Y값&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;yerr = yerr값&lt;/code&gt; : 데이터 편차 리스트&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;uplims = True/False&lt;/code&gt; : 상한가 기호 표시&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;lolims = True/False&lt;/code&gt; : 하한가 기호 표시&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;# 예제 코드
x = [1, 2, 3, 4]
y = [1, 4, 9, 16]
yerr = [2.3, 3.1, 1.7, 2.5]

plt.errorbar(x, y, yerr=yerr)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/68007145/118971263-2a49f180-b9aa-11eb-8d85-d4d628e230e4.png&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;비대칭인 편차를 표시하려면 (2, N) 형태의 값들을 입력.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;첫번째 튜플 : 아래 방향 편차&lt;/li&gt;
&lt;li&gt;두번째 튜플 : 위 방향 편차&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;x = [1, 2, 3, 4]
y = [1, 4, 9, 16]
yerr = [(2.3, 3.1, 1.7, 2.5), (1.1, 2.5, 0.9, 3.9)]

plt.errorbar(x, y, yerr=yerr)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/68007145/118971402-57969f80-b9aa-11eb-88a6-f18d87405953.png&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;파이 차트 그리기&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;원그래프는 범주별 구성 비율을 원형으로 표현한 그래프이다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h3&gt;pie()&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;첫번째 인자 : 각 영역의 비율 리스트&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;labels = 리스트&lt;/code&gt; : 각 영역의 이름 리스트&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;autopct = &apos;%.1f%%&apos;&lt;/code&gt; : 표시될 숫자의 형식&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;startangle = 값&lt;/code&gt; : 시작 각도(default : 0도) 지정&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;counterclock = False&lt;/code&gt; : 시계 방향 순서로 부채꼴 영역이 표시됨&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;explode = 리스트&lt;/code&gt; : 부채꼴이 파이 차트 중심에서 벗어나는 정도를 설정(각각의 영역에 따라 리스트로 지정)&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;shadow = True&lt;/code&gt; : 그림자 표시&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;colors = 리스트&lt;/code&gt; : 각 영역당 색상 지정(리스트로)&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;wedgeprops = 딕셔너리&lt;/code&gt; : 부채꼴 영역의 스타일 설정(딕셔너리의 ‘width’-너비, ‘edgecolor’- 테두리 색깔, ‘linewidth’- 테두리 선의 너비)&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;# 예제 코드
ratio = [34, 32, 16, 18]
labels = [&apos;Apple&apos;, &apos;Banana&apos;, &apos;Melon&apos;, &apos;Grapes&apos;]
colors = [&apos;#ff9999&apos;, &apos;#ffc000&apos;, &apos;#8fd9b6&apos;, &apos;#d395d0&apos;]
wedgeprops={&apos;width&apos;: 0.7, &apos;edgecolor&apos;: &apos;w&apos;, &apos;linewidth&apos;: 5}

plt.pie(ratio, labels=labels, autopct=&apos;%.1f%%&apos;, startangle=260, counterclock=False, colors=colors, wedgeprops=wedgeprops)
plt.show()&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;img src=&quot;https://user-images.githubusercontent.com/68007145/118972808-ee179080-b9ab-11eb-9ed3-e409211cb310.png&quot; alt=&quot;image&quot;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;h3&gt;인간이 인간이라도 믿도록 속일 수 있다면&lt;/h3&gt;
&lt;p&gt;computers are intelligent if you can deceive people&lt;/p&gt;
&lt;h3&gt;컴퓨터는 지능적이라고 할 만합니다. -앨런 튜링(Allen Turing)&lt;/h3&gt;
&lt;p&gt;to believe they are humans.&lt;/p&gt;
&lt;/blockquote&gt;</content:encoded></item><item><title><![CDATA[Keras 모델 생성 방법(Keras models)]]></title><description><![CDATA[Keras 모델 생성 방법(Keras models) 케라스의 구현 방식에는 Sequential API, Functional API, Subclassing API 총…]]></description><link>https://bosoek.github.io/model_Creation/</link><guid isPermaLink="false">https://bosoek.github.io/model_Creation/</guid><pubDate>Sun, 11 Jul 2021 10:00:00 GMT</pubDate><content:encoded>&lt;hr&gt;
&lt;h1&gt;Keras 모델 생성 방법(Keras models)&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;케라스의 구현 방식에는 Sequential API, Functional API, Subclassing API 총 3가지 구현 방식이 존재합니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;img src=&quot;https://wikidocs.net/images/page/106897/1_WzwKtnA0LEhiCGdWTTpLaA.png&quot; width=&quot;700&quot;&gt;
&lt;p&gt;오늘은 각 방식을 사용하며 모델을 생성하는 방법을 공부해 봅니다.&lt;/p&gt;
&lt;h3&gt;1. Sequential API를 사용한 모델 생성&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Sequential() 함수로 model 박스를 생성 후 add() 함수로 레이어들을 선택해 모델에 넣어준다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;직관적이고 ML 책에서 많이 사용되는 방식이다.&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;장점 : 단순하게 층을 샇는 방식으로 쉽고 사용하기가 간단하다.&lt;/li&gt;
&lt;li&gt;단점 : 다수의 입출력을 가진 모델 또는 층 간의 연결이나 덧셈 같은 연산 모델 구현에는 적합하지 않다.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;# 예제 코드
from keras.models import Sequential
from keras.layers import Dense, Activation

model = Sequential([
    Dense(32, activate=&apos;relu&apos;, input_shape=(784,)),
    Dense(10, activate=&apos;softmax&apos;)
])&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;model = Sequential()
model.add(Dense(32, activate=&apos;relu&apos;, input_dim=784))
model.add(Dense(10, activate=&apos;softmax&apos;))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;hr&gt;
&lt;h3&gt;2. Functional API를 이용한 모델 생성&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;input Layer를 변수에 정의한다.&lt;/li&gt;
&lt;li&gt;Dense Layer를 선언시에는 이전 레이어의 변수 정보를 레이어 선언 뒤에 ()가로로 넣어줘야한다.&lt;/li&gt;
&lt;li&gt;Model Class 방식은 &lt;strong&gt;input layer를 input 함수&lt;/strong&gt; 로, &lt;strong&gt;Dense layer를 output 함수&lt;/strong&gt; 로 넣어 모델을 만든다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;multi input과 multi output의 정의가 용이하다.&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;장점 : 구현하기 어려운 복잡한 모델들을 구현할 수 있다.&lt;/li&gt;
&lt;li&gt;단점 : 입력층을 모델의 앞단에 정의해야 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;# 예제 코드
inputs = Input(shape=(1,)) # &amp;lt;-- 해당 부분
output = Dense(1, activation=&apos;linear&apos;)(inputs)
linear_model = Model(inputs, output)

sgd = optimizers.SGD(lr=0.01)

linear_model.compile(optimizer=sgd, loss=&apos;mse&apos;, metrics=[&apos;mse&apos;])
linear_model.fit(X, y, epochs=300)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;hr&gt;
&lt;h3&gt;3. Subclassing API로 인공지능 망 만들기&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;init&lt;/strong&gt; 함수로 클래스의 매개변수를 지정한다.&lt;/li&gt;
&lt;li&gt;매개변수 정보를 이용해 layer들을 선언한다&lt;/li&gt;
&lt;li&gt;call 같은 특정 함수로 모델을 반환한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;모델 레이어를 세세하게 수정하고, 모델을 여러번 만들어야 하는 연구등에 사용된다.&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;장점 : Functional API로도 구현 안되는 모델들도 구현이 가능하다.&lt;/li&gt;
&lt;li&gt;단점 : 객체 지향 프로그래밍에 익숙해야 하고 코드 사용이 까다롭다.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;# 예제 코드
class SimpleMLP(keras.Model):
    def __init__(self, num_classes=10):
        super(SimpleMLP, self).__init__(name=&apos;mlp&apos;)
        self.num_classes = num_classes

        self.dense1 = keras.layers.Dense(32, activation=&apos;relu&apos;)
        self.dense2 = keras.layers.Dense(num_classes, activation=&apos;softmax&apos;)

    def call(self, inputs):
        x = self.dense1(inputs)
        return self.dense2(x)

model = SimpleMLP()
model.compile(...)
model.fit(...)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;h3&gt;인공지능은 인류에게 작동하고 있는 가장 심오한 것 중 하나이다.&lt;/h3&gt;
&lt;p&gt;A.I is one of the most profound things that works for mankind.&lt;/p&gt;
&lt;h3&gt;불이나 전기보다 더 심오하다. -순다르 피차이(Sundar Pichai)&lt;/h3&gt;
&lt;p&gt;It is more profound than fir or electricity.&lt;/p&gt;
&lt;/blockquote&gt;</content:encoded></item><item><title><![CDATA[데이터 중요도 파악(Permutation Importance)]]></title><description><![CDATA[데이터 중요도 파악(Permutation Importance) 모델의 레이블에 영향을 주는 Feature의 중요도를 Sklearn의 Permutation Importance 를 사용해 파악한다. Permutation Importance…]]></description><link>https://bosoek.github.io/Data-Importance/</link><guid isPermaLink="false">https://bosoek.github.io/Data-Importance/</guid><pubDate>Sun, 09 May 2021 10:00:00 GMT</pubDate><content:encoded>&lt;hr&gt;
&lt;h1&gt;데이터 중요도 파악(Permutation Importance)&lt;/h1&gt;
&lt;p&gt;모델의 레이블에 영향을 주는 Feature의 중요도를 &lt;strong&gt;Sklearn의 Permutation Importance&lt;/strong&gt; 를 사용해 파악한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h3&gt;Permutation Importance&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;모델 예측시 가장 영향을 많이 주는 Feature를 파악하는 방법&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;모델의 훈련이 끝난 후 계산되며 &lt;strong&gt;모델이 특정 Feature를 안썻을때, 성능 손실에 얼마나 영향을 주는지로 그 Feature의 중요도를 파악하는 방법&lt;/strong&gt; 이다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;어떤 모델이든 적용 가능하다!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h3&gt;Permutation Importance의 장점&lt;/h3&gt;
&lt;p&gt;기존에는 특정 Feature를 제거후 모델을 학습해서 중요도를 파악했지만 자원 소모가 너무 크다.&lt;/p&gt;
&lt;p&gt;때문에 Permutation Importance는 &lt;strong&gt;특정 Feature를 무작위로 섞어 Target과의 연결 고리를 끊어 해당 Feature를 안쓰는 것처럼(노이즈)&lt;/strong&gt; 만든다.&lt;/p&gt;
&lt;p&gt;그후 예측값과 실제값의 차이가 더 생겼는지로 해당 Feature의 영향력을 파악한다.&lt;/p&gt;
&lt;p&gt;이러한 과정 덕분에 &lt;strong&gt;모델의 재학습이 필요없다!&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;훈련 모델과 데이터만 있으면 변수 중요도를 뽑을 수 있다. 반대로 모델 학습 과정, 내부 구조 정보가 필요 없어서 어느 모델이든 적용 가능하다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;&lt;strong&gt;Permutation Importance의 다른 특징은 각 Feature의 중요도에는 다른 Feature와의 상호작용도 포함된다는 것이다!&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;특정 Feature를 섞으면 다른 Feature와의 관계가 끝어져서 해당 Feature와의 모든 상호작용이 사라진다. 때문에 두 Feature간 상호작용의 영향은 두개의 Feature Importance에 중복 포함된다.&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h3&gt;Permutation Importance의 단점&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;특정 Feature를 무작위로 섞어서 실행시마다 Feature Importance 결과가 달라진다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;섞는 횟수를 늘려 예측 에러 분산을 감소할 수 있지만 Feature 개수가 많을 경우 연살량이 증가하기 때문에 Permutation의 적절한 회수를 선택해야한다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Feature를 무작위로 섞기에 비현실적인 데이터 조합이 생길 수 있다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Feature간 상관관계가 높을 경우 발샐할 수 있으며 이런 데이터의 비개연성, 비현실성이 증가하면 예측값에 영향을 미칠 가능성이 있고 우리가 원하던 결과가 아니기에 이를 염두하고 해석해야한다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;예로, 키와 몸무게를 랜덤하게 섞다보면 키가 2m인데 몸무게가 30kg인 데이터가 만들어 질 수도 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h3&gt;실행 코드&lt;/h3&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;from sklearn.inspection import permutation_importance # sklearn 22 버전부터 해당
from sklearn.metrics import make_scorer

# MAPE
def mean_absolute_percentage_error(y_test, y_pred):
    y_test, y_pred = np.array(y_test), np.array(y_pred)
    return np.mean(np.abs((y_test - y_pred) / y_test)) * 100

# fix_model : 훈련된 모델
# X_train : 훈련데이터 Feature
# y_train : 훈련데이터 Target
# scoring : Feature 를 Shuffler 한 뒤, 예측값과 실제값을 어떤 Metric 을 사용해 비교할지
# n_repeats : 특정 Feature 를 몇번 Shuffle 할 것인지
# random_state : 난수 고정
result = permutation_importance(fix_model, X_train, y_train, scoring = make_scorer(mean_absolute_percentage_error,greater_is_better=False),
                            n_repeats=30,
                            random_state=0)
# Feature label
Feature = train[[&apos;lr&apos;,&apos;lc&apos;,&apos;rc&apos;,&apos;ld&apos;,&apos;rd&apos;,&apos;lnnz&apos;,&apos;rnnz&apos;,&apos;lr*lc&apos;,&apos;lc*rc&apos;,&apos;lr*rc&apos;]] 

# Feature 중요도를 오름차순으로 정렬한 뒤, 해당 Feature 의 index 를 저장
sorted_result = result.importances_mean.argsort()

# 결과를 DataFrame 화
importances = pd.DataFrame(result.importances_mean[sorted_result], index=Feature.columns[sorted_result]).sort_values(0, ascending=False)   
importances&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;h3&gt;만약 인간의 뇌가 우리가 이해할 수 있을 정도로 단순하다면,&lt;/h3&gt;
&lt;p&gt;if the human brain was simple enough for us to understand,&lt;/p&gt;
&lt;h3&gt;우리는 그렇게 단순할 수 없을 것이다. -에머슨 M.푸(Emerson M. Pooh)&lt;/h3&gt;
&lt;p&gt;we wouldn’t be that simple.&lt;/p&gt;
&lt;/blockquote&gt;</content:encoded></item><item><title><![CDATA[분류 모델 성능 평가 지표]]></title><description><![CDATA[분류 모델 성능 평가 지표 분류 모델을 만들고 나면 분류기의 예측력을 검증해야 한다. 이때 분류 모델이 정답을 맞히거나 틀리는 경우들은 총 4가지가 생긴다. 이때 생기는 개념이 1종 오류,…]]></description><link>https://bosoek.github.io/Classification-performance-evaluation/</link><guid isPermaLink="false">https://bosoek.github.io/Classification-performance-evaluation/</guid><pubDate>Mon, 03 May 2021 10:00:00 GMT</pubDate><content:encoded>&lt;hr&gt;
&lt;h1&gt;분류 모델 성능 평가 지표&lt;/h1&gt;
&lt;p&gt;분류 모델을 만들고 나면 분류기의 예측력을 검증해야 한다. 이때 분류 모델이 정답을 맞히거나 틀리는 경우들은 총 4가지가 생긴다.&lt;/p&gt;
&lt;img src=&quot;https://user-images.githubusercontent.com/68007145/137417559-88a972d3-e7cb-4c59-ab36-88bcaf2e19c8.png&quot; width=&quot;700&quot;&gt;
&lt;p&gt;이때 생기는 개념이 1종 오류, 2종 오류이며 각 오류는 분류 과제 성격에 따라 검증이 다르다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;1종 오류(False Positive)&lt;/strong&gt; : 좋은 것이라 예측 하였지만 실제로는 좋지 않은 것인 경우
&lt;blockquote&gt;
&lt;p&gt;예로 중고차 성능 판별이 있다. 좋은 중고차를 나쁜차로 예측해서 구매하지 않아도 손해볼 것은 없지만 나쁜 차를 잘못 예측하여 구매하는 건 손해이다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;2종 오류(True Negative)&lt;/strong&gt; : 나쁜 것이라 예측 하였지만 실제로는 좋은 것인 경우
&lt;blockquote&gt;
&lt;p&gt;암 환자 진단시에는 암 환자를 건강하다고 판별하는 경우가 더 치명적이다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2&gt;위의 성능 평가 개념들을 바탕으로 분류 모델 성능 평가 지표를 알아본다.&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h3&gt;Accuracy(정확도)&lt;/h3&gt;
&lt;img src=&quot;https://user-images.githubusercontent.com/68007145/137418639-c8e45022-8001-4d7d-9545-4e031f5c1707.png&quot;&gt;
&lt;p&gt;전체 예측 건수에서 정답을 맞힌 건수의 비율&lt;/p&gt;
&lt;p&gt;단, 이때 &lt;strong&gt;Negative의 비율이 너무 높아서 Treu Negative로만 Accuracy의 높은 점수를 받는 정확도 역설(Accuracy Paradox)&lt;/strong&gt; 이 발생할 수 있다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;예로, 암 환자 데이터는 90% 정도가 정상이라고 라벨링 되어 있을때 모델이 전부 정상이라고 답해도 정확도가 90%에 도달한다.&lt;br&gt;
하지만 정상이라는 답밖에 내놓지 못하는 모델은 당연히 실제 환자들을 진단할 때 사용할 수 없다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h3&gt;Recall(재현율)&lt;/h3&gt;
&lt;img src=&quot;https://user-images.githubusercontent.com/68007145/137418945-0cf57f47-b04b-4838-bef9-82ebd3e05e5a.png&quot;&gt;
&lt;p&gt;실제 정답이 True인 것들 중 분류기가 True로 예측한 비율&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;때문에 True 발생 확률이 적을 때나 정확도 역설 시 사용하기 좋다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;하지만 &lt;strong&gt;True로만 답하는 모델이 있을 시 accuracy 점수는 낮지만 Recall 점수는 1로 만점&lt;/strong&gt; 이 될 수 있는 문제점이 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h3&gt;Precision(정밀도)&lt;/h3&gt;
&lt;img src=&quot;https://user-images.githubusercontent.com/68007145/137419012-61135a87-7127-4398-ab5f-16c290912d08.png&quot;&gt;
&lt;p&gt;모델이 True라고 예측한 것 중에 실제 값이 True인 비율&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;True로만 답하는 모델이 있을 시 Recall에서는 1이지만 모델이 답한 True중 &lt;strong&gt;실제 True인 데이터는 일부&lt;/strong&gt; 이기 때문에 Precision에서는 0점에 가깝게 나온다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Precision은 Recall의 반대 개념 지표이다. 즉, 하나가 올라가면 하나가 내려간다. 때문에 Recall의 장점은 Precision의 단점이 되기도 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h3&gt;F1 Score&lt;/h3&gt;
&lt;img src=&quot;https://user-images.githubusercontent.com/68007145/137419035-d8c184f3-8988-4d99-89ad-840d37cd62fa.png&quot;&gt;
&lt;p&gt;Recall과 Precision의 조화평균으로써 Recall과 Precision 둘 중 하나의 값이 낮을때 그부분이 지표에 잘 반영되도록 하기 위해 일반적인 산술 평균이 아닌 조화 평균을 사용한다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;예로, recall과 precision이 각각 1과 0.01을 가졌을 때 산술 평균은 &lt;code class=&quot;language-text&quot;&gt;(1 + 0.01) / 2 = 0.505&lt;/code&gt;로 절반 정도 맞히는 걸로 보이지만 조화 평균시에는 &lt;code class=&quot;language-text&quot;&gt;2 * (1 * 0.01) / (1 + 0.01) = 0.019&lt;/code&gt;로 낮게 나온다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Scikit-Learn을 통한 통계 지표 확인&lt;/h2&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;from sklearn.metrics import accuracy_score, recall_score, precision_score, f1_score

labels = [1, 0, 0, 1, 1, 1, 0, 1, 1, 1]
guesses = [0, 1, 1, 1, 1, 0, 1, 0, 1, 0]

print(accuracy_score(labels, guesses))
print(recall_score(labels, guesses))
print(precision_score(labels, guesses))
print(f1_score(labels, guesses))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;h3&gt;문제는 지적인 기계가 어떤 감정을 가질 수 있느냐가 아니라,&lt;/h3&gt;
&lt;p&gt;The question is not what emotions an intelligent machine can have,&lt;/p&gt;
&lt;h3&gt;기계가 아무런 감정 없이 지능을 가질 수 있느냐 하는 것이다. -마빈 민스키(Marvin Minski)&lt;/h3&gt;
&lt;p&gt;but whether it can have intelligence without any emotions.&lt;/p&gt;
&lt;/blockquote&gt;</content:encoded></item></channel></rss>